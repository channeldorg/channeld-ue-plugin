// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: unreal_common.proto

#ifdef _MSC_VER
#	pragma warning(disable: 4125)
#	pragma warning(disable: 4647)
#	pragma warning(disable: 4668)
#	pragma warning(disable: 4800)
#	pragma warning(disable: 4946)
#endif

#include "unreal_common.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace unrealpb {
PROTOBUF_CONSTEXPR FVector::FVector(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0} {}
struct FVectorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FVectorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FVectorDefaultTypeInternal() {}
  union {
    FVector _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FVectorDefaultTypeInternal _FVector_default_instance_;
PROTOBUF_CONSTEXPR UnrealObjectRef_GuidCachedObject::UnrealObjectRef_GuidCachedObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pathname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.netguid_)*/0u
  , /*decltype(_impl_.outerguid_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UnrealObjectRef_GuidCachedObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnrealObjectRef_GuidCachedObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnrealObjectRef_GuidCachedObjectDefaultTypeInternal() {}
  union {
    UnrealObjectRef_GuidCachedObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnrealObjectRef_GuidCachedObjectDefaultTypeInternal _UnrealObjectRef_GuidCachedObject_default_instance_;
PROTOBUF_CONSTEXPR UnrealObjectRef::UnrealObjectRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.context_)*/{}
  , /*decltype(_impl_.netguidbunch_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.classpath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.netguid_)*/0u
  , /*decltype(_impl_.bunchbitsnum_)*/0u
  , /*decltype(_impl_.owningconnid_)*/0u} {}
struct UnrealObjectRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UnrealObjectRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UnrealObjectRefDefaultTypeInternal() {}
  union {
    UnrealObjectRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UnrealObjectRefDefaultTypeInternal _UnrealObjectRef_default_instance_;
PROTOBUF_CONSTEXPR ActorComponentRef::ActorComponentRef(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.compname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_)*/nullptr} {}
struct ActorComponentRefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActorComponentRefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActorComponentRefDefaultTypeInternal() {}
  union {
    ActorComponentRef _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActorComponentRefDefaultTypeInternal _ActorComponentRef_default_instance_;
PROTOBUF_CONSTEXPR RemoteFunctionMessage::RemoteFunctionMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.functionname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.paramspayload_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.targetobj_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RemoteFunctionMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RemoteFunctionMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RemoteFunctionMessageDefaultTypeInternal() {}
  union {
    RemoteFunctionMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RemoteFunctionMessageDefaultTypeInternal _RemoteFunctionMessage_default_instance_;
PROTOBUF_CONSTEXPR SpawnObjectMessage::SpawnObjectMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obj_)*/nullptr
  , /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.channelid_)*/0u
  , /*decltype(_impl_.localrole_)*/0u} {}
struct SpawnObjectMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpawnObjectMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpawnObjectMessageDefaultTypeInternal() {}
  union {
    SpawnObjectMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpawnObjectMessageDefaultTypeInternal _SpawnObjectMessage_default_instance_;
PROTOBUF_CONSTEXPR DestroyObjectMessage::DestroyObjectMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.netid_)*/0u
  , /*decltype(_impl_.reason_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DestroyObjectMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DestroyObjectMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DestroyObjectMessageDefaultTypeInternal() {}
  union {
    DestroyObjectMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DestroyObjectMessageDefaultTypeInternal _DestroyObjectMessage_default_instance_;
PROTOBUF_CONSTEXPR HandoverContext::HandoverContext(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.obj_)*/nullptr
  , /*decltype(_impl_.clientconnid_)*/0u} {}
struct HandoverContextDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HandoverContextDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HandoverContextDefaultTypeInternal() {}
  union {
    HandoverContext _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HandoverContextDefaultTypeInternal _HandoverContext_default_instance_;
PROTOBUF_CONSTEXPR GetHandoverContextMessage::GetHandoverContextMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.netid_)*/0u
  , /*decltype(_impl_.srcchannelid_)*/0u
  , /*decltype(_impl_.dstchannelid_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetHandoverContextMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetHandoverContextMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetHandoverContextMessageDefaultTypeInternal() {}
  union {
    GetHandoverContextMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetHandoverContextMessageDefaultTypeInternal _GetHandoverContextMessage_default_instance_;
PROTOBUF_CONSTEXPR GetHandoverContextResultMessage::GetHandoverContextResultMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.context_)*/{}
  , /*decltype(_impl_.netid_)*/0u
  , /*decltype(_impl_.srcchannelid_)*/0u
  , /*decltype(_impl_.dstchannelid_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetHandoverContextResultMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetHandoverContextResultMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetHandoverContextResultMessageDefaultTypeInternal() {}
  union {
    GetHandoverContextResultMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetHandoverContextResultMessageDefaultTypeInternal _GetHandoverContextResultMessage_default_instance_;
PROTOBUF_CONSTEXPR HandoverData::HandoverData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.context_)*/{}
  , /*decltype(_impl_.channeldata_)*/nullptr} {}
struct HandoverDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HandoverDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HandoverDataDefaultTypeInternal() {}
  union {
    HandoverData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HandoverDataDefaultTypeInternal _HandoverData_default_instance_;
PROTOBUF_CONSTEXPR GetUnrealObjectRefMessage::GetUnrealObjectRefMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.netguid_)*/{}
  , /*decltype(_impl_._netguid_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetUnrealObjectRefMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetUnrealObjectRefMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetUnrealObjectRefMessageDefaultTypeInternal() {}
  union {
    GetUnrealObjectRefMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUnrealObjectRefMessageDefaultTypeInternal _GetUnrealObjectRefMessage_default_instance_;
PROTOBUF_CONSTEXPR GetUnrealObjectRefResultMessage::GetUnrealObjectRefResultMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.objref_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetUnrealObjectRefResultMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetUnrealObjectRefResultMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetUnrealObjectRefResultMessageDefaultTypeInternal() {}
  union {
    GetUnrealObjectRefResultMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUnrealObjectRefResultMessageDefaultTypeInternal _GetUnrealObjectRefResultMessage_default_instance_;
PROTOBUF_CONSTEXPR SpatialEntityState::SpatialEntityState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.objref_)*/nullptr
  , /*decltype(_impl_.entitydata_)*/nullptr
  , /*decltype(_impl_.removed_)*/false} {}
struct SpatialEntityStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpatialEntityStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpatialEntityStateDefaultTypeInternal() {}
  union {
    SpatialEntityState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpatialEntityStateDefaultTypeInternal _SpatialEntityState_default_instance_;
PROTOBUF_CONSTEXPR SpatialChannelData_EntitiesEntry_DoNotUse::SpatialChannelData_EntitiesEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct SpatialChannelData_EntitiesEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpatialChannelData_EntitiesEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpatialChannelData_EntitiesEntry_DoNotUseDefaultTypeInternal() {}
  union {
    SpatialChannelData_EntitiesEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpatialChannelData_EntitiesEntry_DoNotUseDefaultTypeInternal _SpatialChannelData_EntitiesEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR SpatialChannelData::SpatialChannelData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.entities_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SpatialChannelDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SpatialChannelDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SpatialChannelDataDefaultTypeInternal() {}
  union {
    SpatialChannelData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SpatialChannelDataDefaultTypeInternal _SpatialChannelData_default_instance_;
PROTOBUF_CONSTEXPR FRepMovement::FRepMovement(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.linearvelocity_)*/nullptr
  , /*decltype(_impl_.angularvelocity_)*/nullptr
  , /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.bsimulatedphysicsleep_)*/false
  , /*decltype(_impl_.brepphysics_)*/false} {}
struct FRepMovementDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FRepMovementDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FRepMovementDefaultTypeInternal() {}
  union {
    FRepMovement _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FRepMovementDefaultTypeInternal _FRepMovement_default_instance_;
PROTOBUF_CONSTEXPR FRepAttachment::FRepAttachment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attachsocket_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attachparent_)*/nullptr
  , /*decltype(_impl_.locationoffset_)*/nullptr
  , /*decltype(_impl_.relativescale_)*/nullptr
  , /*decltype(_impl_.rotationoffset_)*/nullptr
  , /*decltype(_impl_.attachcomponent_)*/nullptr} {}
struct FRepAttachmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FRepAttachmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FRepAttachmentDefaultTypeInternal() {}
  union {
    FRepAttachment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FRepAttachmentDefaultTypeInternal _FRepAttachment_default_instance_;
PROTOBUF_CONSTEXPR ActorState::ActorState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.owner_)*/nullptr
  , /*decltype(_impl_.instigator_)*/nullptr
  , /*decltype(_impl_.replicatedmovement_)*/nullptr
  , /*decltype(_impl_.attachmentreplication_)*/nullptr
  , /*decltype(_impl_.owningconnid_)*/0u
  , /*decltype(_impl_.localrole_)*/0u
  , /*decltype(_impl_.removed_)*/false
  , /*decltype(_impl_.breplicatemovement_)*/false
  , /*decltype(_impl_.bhidden_)*/false
  , /*decltype(_impl_.btearoff_)*/false
  , /*decltype(_impl_.remoterole_)*/0u
  , /*decltype(_impl_.bcanbedamaged_)*/false} {}
struct ActorStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActorStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActorStateDefaultTypeInternal() {}
  union {
    ActorState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActorStateDefaultTypeInternal _ActorState_default_instance_;
PROTOBUF_CONSTEXPR ActorComponentState::ActorComponentState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.removed_)*/false
  , /*decltype(_impl_.bisactive_)*/false
  , /*decltype(_impl_.breplicated_)*/false} {}
struct ActorComponentStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ActorComponentStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ActorComponentStateDefaultTypeInternal() {}
  union {
    ActorComponentState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ActorComponentStateDefaultTypeInternal _ActorComponentState_default_instance_;
PROTOBUF_CONSTEXPR SceneComponentState::SceneComponentState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.attachchildren_)*/{}
  , /*decltype(_impl_.attachsocketname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.attachparent_)*/nullptr
  , /*decltype(_impl_.relativelocation_)*/nullptr
  , /*decltype(_impl_.relativerotation_)*/nullptr
  , /*decltype(_impl_.relativescale_)*/nullptr
  , /*decltype(_impl_.removed_)*/false
  , /*decltype(_impl_.babsolutelocation_)*/false
  , /*decltype(_impl_.babsoluterotation_)*/false
  , /*decltype(_impl_.babsolutescale_)*/false
  , /*decltype(_impl_.bvisible_)*/false
  , /*decltype(_impl_.bshouldbeattached_)*/false
  , /*decltype(_impl_.bshouldsnaplocationwhenattached_)*/false
  , /*decltype(_impl_.bshouldsnaprotationwhenattached_)*/false} {}
struct SceneComponentStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SceneComponentStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SceneComponentStateDefaultTypeInternal() {}
  union {
    SceneComponentState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SceneComponentStateDefaultTypeInternal _SceneComponentState_default_instance_;
PROTOBUF_CONSTEXPR FBasedMovementInfo::FBasedMovementInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.bonename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.movementbase_)*/nullptr
  , /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.bserverhasbasecomponent_)*/false
  , /*decltype(_impl_.brelativerotation_)*/false
  , /*decltype(_impl_.bserverhasvelocity_)*/false} {}
struct FBasedMovementInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FBasedMovementInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FBasedMovementInfoDefaultTypeInternal() {}
  union {
    FBasedMovementInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FBasedMovementInfoDefaultTypeInternal _FBasedMovementInfo_default_instance_;
PROTOBUF_CONSTEXPR FRootMotionSource_FRootMotionFinishVelocitySettings::FRootMotionSource_FRootMotionFinishVelocitySettings(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.setvelocity_)*/nullptr
  , /*decltype(_impl_.mode_)*/0u
  , /*decltype(_impl_.clampvelocity_)*/0} {}
struct FRootMotionSource_FRootMotionFinishVelocitySettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FRootMotionSource_FRootMotionFinishVelocitySettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FRootMotionSource_FRootMotionFinishVelocitySettingsDefaultTypeInternal() {}
  union {
    FRootMotionSource_FRootMotionFinishVelocitySettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FRootMotionSource_FRootMotionFinishVelocitySettingsDefaultTypeInternal _FRootMotionSource_FRootMotionFinishVelocitySettings_default_instance_;
PROTOBUF_CONSTEXPR FRootMotionSource::FRootMotionSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.instancename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.finishvelocityparams_)*/nullptr
  , /*decltype(_impl_.priority_)*/0u
  , /*decltype(_impl_.localid_)*/0u
  , /*decltype(_impl_.accumulatedmode_)*/0u
  , /*decltype(_impl_.starttime_)*/0
  , /*decltype(_impl_.currenttime_)*/0
  , /*decltype(_impl_.previoustime_)*/0
  , /*decltype(_impl_.duration_)*/0
  , /*decltype(_impl_.status_)*/0u
  , /*decltype(_impl_.settings_)*/0u
  , /*decltype(_impl_.binlocalspace_)*/false
  , /*decltype(_impl_.bneedssimulatedcatchup_)*/false
  , /*decltype(_impl_.bsimulatedneedssmoothing_)*/false
  , /*decltype(_impl_.bhasrootmotion_)*/false
  , /*decltype(_impl_.blendweight_)*/0} {}
struct FRootMotionSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FRootMotionSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FRootMotionSourceDefaultTypeInternal() {}
  union {
    FRootMotionSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FRootMotionSourceDefaultTypeInternal _FRootMotionSource_default_instance_;
PROTOBUF_CONSTEXPR FRootMotionSourceGroup::FRootMotionSourceGroup(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rootmotionsources_)*/{}
  , /*decltype(_impl_.pendingaddrootmotionsources_)*/{}
  , /*decltype(_impl_.lastpreadditivevelocity_)*/nullptr
  , /*decltype(_impl_.bhasadditivesources_)*/false
  , /*decltype(_impl_.bhasoverridesources_)*/false
  , /*decltype(_impl_.bhasoverridesourceswithignorezaccumulate_)*/false
  , /*decltype(_impl_.bisadditivevelocityapplied_)*/false
  , /*decltype(_impl_.lastaccumulatedsettings_)*/0u} {}
struct FRootMotionSourceGroupDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FRootMotionSourceGroupDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FRootMotionSourceGroupDefaultTypeInternal() {}
  union {
    FRootMotionSourceGroup _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FRootMotionSourceGroupDefaultTypeInternal _FRootMotionSourceGroup_default_instance_;
PROTOBUF_CONSTEXPR FRepRootMotionMontage::FRepRootMotionMontage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.movementbasebonename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.animmontage_)*/nullptr
  , /*decltype(_impl_.location_)*/nullptr
  , /*decltype(_impl_.rotation_)*/nullptr
  , /*decltype(_impl_.movementbase_)*/nullptr
  , /*decltype(_impl_.authoritativerootmotion_)*/nullptr
  , /*decltype(_impl_.acceleration_)*/nullptr
  , /*decltype(_impl_.linearvelocity_)*/nullptr
  , /*decltype(_impl_.position_)*/0
  , /*decltype(_impl_.bisactive_)*/false
  , /*decltype(_impl_.brelativeposition_)*/false
  , /*decltype(_impl_.brelativerotation_)*/false} {}
struct FRepRootMotionMontageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FRepRootMotionMontageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FRepRootMotionMontageDefaultTypeInternal() {}
  union {
    FRepRootMotionMontage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FRepRootMotionMontageDefaultTypeInternal _FRepRootMotionMontage_default_instance_;
PROTOBUF_CONSTEXPR CharacterState::CharacterState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rootmotion_)*/nullptr
  , /*decltype(_impl_.basedmovement_)*/nullptr
  , /*decltype(_impl_.serverlasttransformupdatetimestamp_)*/0
  , /*decltype(_impl_.movementmode_)*/0u
  , /*decltype(_impl_.biscrouched_)*/false
  , /*decltype(_impl_.bproxyisjumpforceapplied_)*/false
  , /*decltype(_impl_.animrootmotiontranslationscale_)*/0
  , /*decltype(_impl_.replaylasttransformupdatetimestamp_)*/0} {}
struct CharacterStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CharacterStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CharacterStateDefaultTypeInternal() {}
  union {
    CharacterState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CharacterStateDefaultTypeInternal _CharacterState_default_instance_;
PROTOBUF_CONSTEXPR Character_ServerMovePacked_Params::Character_ServerMovePacked_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.packedbits_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bitsnum_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Character_ServerMovePacked_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Character_ServerMovePacked_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Character_ServerMovePacked_ParamsDefaultTypeInternal() {}
  union {
    Character_ServerMovePacked_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Character_ServerMovePacked_ParamsDefaultTypeInternal _Character_ServerMovePacked_Params_default_instance_;
PROTOBUF_CONSTEXPR Character_ClientMoveResponsePacked_Params::Character_ClientMoveResponsePacked_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.packedbits_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.bitsnum_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Character_ClientMoveResponsePacked_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Character_ClientMoveResponsePacked_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Character_ClientMoveResponsePacked_ParamsDefaultTypeInternal() {}
  union {
    Character_ClientMoveResponsePacked_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Character_ClientMoveResponsePacked_ParamsDefaultTypeInternal _Character_ClientMoveResponsePacked_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerState::PlayerState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.playername_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.score_)*/0
  , /*decltype(_impl_.playerid_)*/0
  , /*decltype(_impl_.ping_)*/0u} {}
struct PlayerStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerStateDefaultTypeInternal() {}
  union {
    PlayerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerStateDefaultTypeInternal _PlayerState_default_instance_;
PROTOBUF_CONSTEXPR ControllerState::ControllerState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.playerstate_)*/nullptr
  , /*decltype(_impl_.pawn_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ControllerStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ControllerStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ControllerStateDefaultTypeInternal() {}
  union {
    ControllerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ControllerStateDefaultTypeInternal _ControllerState_default_instance_;
PROTOBUF_CONSTEXPR Controller_ClientSetLocation_Params::Controller_ClientSetLocation_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.newlocation_)*/nullptr
  , /*decltype(_impl_.newrotation_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Controller_ClientSetLocation_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Controller_ClientSetLocation_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Controller_ClientSetLocation_ParamsDefaultTypeInternal() {}
  union {
    Controller_ClientSetLocation_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Controller_ClientSetLocation_ParamsDefaultTypeInternal _Controller_ClientSetLocation_Params_default_instance_;
PROTOBUF_CONSTEXPR Controller_ClientSetRotation_Params::Controller_ClientSetRotation_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.newrotation_)*/nullptr
  , /*decltype(_impl_.bresetcamera_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct Controller_ClientSetRotation_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Controller_ClientSetRotation_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Controller_ClientSetRotation_ParamsDefaultTypeInternal() {}
  union {
    Controller_ClientSetRotation_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Controller_ClientSetRotation_ParamsDefaultTypeInternal _Controller_ClientSetRotation_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerControllerState::PlayerControllerState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.targetviewrotation_)*/nullptr
  , /*decltype(_impl_.spawnlocation_)*/nullptr} {}
struct PlayerControllerStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerControllerStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerControllerStateDefaultTypeInternal() {}
  union {
    PlayerControllerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerControllerStateDefaultTypeInternal _PlayerControllerState_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ServerUpdateCamera_Params::PlayerController_ServerUpdateCamera_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.camloc_)*/nullptr
  , /*decltype(_impl_.campitchandyaw_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ServerUpdateCamera_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ServerUpdateCamera_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ServerUpdateCamera_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ServerUpdateCamera_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ServerUpdateCamera_ParamsDefaultTypeInternal _PlayerController_ServerUpdateCamera_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientSetHUD_Params::PlayerController_ClientSetHUD_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hudclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct PlayerController_ClientSetHUD_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientSetHUD_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientSetHUD_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientSetHUD_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientSetHUD_ParamsDefaultTypeInternal _PlayerController_ClientSetHUD_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientSetViewTarget_Params::PlayerController_ClientSetViewTarget_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.actor_)*/nullptr
  , /*decltype(_impl_.blendtime_)*/0
  , /*decltype(_impl_.blendfunction_)*/0u
  , /*decltype(_impl_.blendexp_)*/0
  , /*decltype(_impl_.blockoutgoing_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientSetViewTarget_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientSetViewTarget_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientSetViewTarget_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientSetViewTarget_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientSetViewTarget_ParamsDefaultTypeInternal _PlayerController_ClientSetViewTarget_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientEnableNetworkVoice_Params::PlayerController_ClientEnableNetworkVoice_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.benable_)*/false} {}
struct PlayerController_ClientEnableNetworkVoice_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientEnableNetworkVoice_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientEnableNetworkVoice_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientEnableNetworkVoice_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientEnableNetworkVoice_ParamsDefaultTypeInternal _PlayerController_ClientEnableNetworkVoice_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientCapBandwidth_Params::PlayerController_ClientCapBandwidth_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.cap_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientCapBandwidth_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientCapBandwidth_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientCapBandwidth_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientCapBandwidth_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientCapBandwidth_ParamsDefaultTypeInternal _PlayerController_ClientCapBandwidth_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientRestart_Params::PlayerController_ClientRestart_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pawn_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientRestart_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientRestart_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientRestart_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientRestart_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientRestart_ParamsDefaultTypeInternal _PlayerController_ClientRestart_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientSetCameraMode_Params::PlayerController_ClientSetCameraMode_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.newcammode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientSetCameraMode_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientSetCameraMode_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientSetCameraMode_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientSetCameraMode_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientSetCameraMode_ParamsDefaultTypeInternal _PlayerController_ClientSetCameraMode_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientRetryClientRestart_Params::PlayerController_ClientRetryClientRestart_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pawn_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientRetryClientRestart_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientRetryClientRestart_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientRetryClientRestart_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientRetryClientRestart_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientRetryClientRestart_ParamsDefaultTypeInternal _PlayerController_ClientRetryClientRestart_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ServerSetSpectatorLocation_Params::PlayerController_ServerSetSpectatorLocation_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.newloc_)*/nullptr
  , /*decltype(_impl_.newrot_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ServerSetSpectatorLocation_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ServerSetSpectatorLocation_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ServerSetSpectatorLocation_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ServerSetSpectatorLocation_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ServerSetSpectatorLocation_ParamsDefaultTypeInternal _PlayerController_ServerSetSpectatorLocation_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ServerAcknowledgePossession_Params::PlayerController_ServerAcknowledgePossession_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pawn_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ServerAcknowledgePossession_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ServerAcknowledgePossession_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ServerAcknowledgePossession_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ServerAcknowledgePossession_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ServerAcknowledgePossession_ParamsDefaultTypeInternal _PlayerController_ServerAcknowledgePossession_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientGotoState_Params::PlayerController_ClientGotoState_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.newstate_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientGotoState_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientGotoState_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientGotoState_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientGotoState_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientGotoState_ParamsDefaultTypeInternal _PlayerController_ClientGotoState_Params_default_instance_;
PROTOBUF_CONSTEXPR PlayerController_ClientReceiveLocalizedMessage_Params::PlayerController_ClientReceiveLocalizedMessage_Params(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.relatedplayerstate_1_)*/nullptr
  , /*decltype(_impl_.relatedplayerstate_2_)*/nullptr
  , /*decltype(_impl_.optionalobject_)*/nullptr
  , /*decltype(_impl_.switch__)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlayerController_ClientReceiveLocalizedMessage_ParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlayerController_ClientReceiveLocalizedMessage_ParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlayerController_ClientReceiveLocalizedMessage_ParamsDefaultTypeInternal() {}
  union {
    PlayerController_ClientReceiveLocalizedMessage_Params _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlayerController_ClientReceiveLocalizedMessage_ParamsDefaultTypeInternal _PlayerController_ClientReceiveLocalizedMessage_Params_default_instance_;
PROTOBUF_CONSTEXPR GameStateBase::GameStateBase(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.spectatorclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gamemodeclassname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.replicatedworldtimeseconds_)*/0
  , /*decltype(_impl_.breplicatedhasbegunplay_)*/false} {}
struct GameStateBaseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GameStateBaseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GameStateBaseDefaultTypeInternal() {}
  union {
    GameStateBase _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GameStateBaseDefaultTypeInternal _GameStateBase_default_instance_;
PROTOBUF_CONSTEXPR PawnState::PawnState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.playerstate_)*/nullptr
  , /*decltype(_impl_.controller_)*/nullptr
  , /*decltype(_impl_.remoteviewpitch_)*/0u} {}
struct PawnStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PawnStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PawnStateDefaultTypeInternal() {}
  union {
    PawnState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PawnStateDefaultTypeInternal _PawnState_default_instance_;
PROTOBUF_CONSTEXPR FClientAdjustment::FClientAdjustment(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.newbasebonename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.newloc_)*/nullptr
  , /*decltype(_impl_.newvel_)*/nullptr
  , /*decltype(_impl_.newrot_)*/nullptr
  , /*decltype(_impl_.newbase_)*/nullptr
  , /*decltype(_impl_.rootmotionsourcecorrection_)*/nullptr
  , /*decltype(_impl_.rootmotionrotation_)*/nullptr
  , /*decltype(_impl_.timestamp_)*/0
  , /*decltype(_impl_.backgoodmove_)*/false
  , /*decltype(_impl_.bbaserelativeposition_)*/false
  , /*decltype(_impl_.movementmode_)*/0u} {}
struct FClientAdjustmentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FClientAdjustmentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FClientAdjustmentDefaultTypeInternal() {}
  union {
    FClientAdjustment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FClientAdjustmentDefaultTypeInternal _FClientAdjustment_default_instance_;
}  // namespace unrealpb
static ::_pb::Metadata file_level_metadata_unreal_5fcommon_2eproto[49];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_unreal_5fcommon_2eproto[2];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_unreal_5fcommon_2eproto = nullptr;

const uint32_t TableStruct_unreal_5fcommon_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::unrealpb::FVector, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FVector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FVector, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FVector, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FVector, _impl_.z_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef_GuidCachedObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef_GuidCachedObject, _impl_.netguid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef_GuidCachedObject, _impl_.pathname_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef_GuidCachedObject, _impl_.outerguid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_.netguid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_.context_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_.netguidbunch_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_.bunchbitsnum_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_.classpath_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::UnrealObjectRef, _impl_.owningconnid_),
  2,
  ~0u,
  0,
  3,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentRef, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentRef, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentRef, _impl_.owner_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentRef, _impl_.compname_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::RemoteFunctionMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::RemoteFunctionMessage, _impl_.targetobj_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::RemoteFunctionMessage, _impl_.functionname_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::RemoteFunctionMessage, _impl_.paramspayload_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpawnObjectMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpawnObjectMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpawnObjectMessage, _impl_.obj_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpawnObjectMessage, _impl_.channelid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpawnObjectMessage, _impl_.localrole_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpawnObjectMessage, _impl_.location_),
  ~0u,
  1,
  2,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::DestroyObjectMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::DestroyObjectMessage, _impl_.netid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::DestroyObjectMessage, _impl_.reason_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::HandoverContext, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::HandoverContext, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::HandoverContext, _impl_.obj_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::HandoverContext, _impl_.clientconnid_),
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetHandoverContextMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetHandoverContextMessage, _impl_.netid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetHandoverContextMessage, _impl_.srcchannelid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetHandoverContextMessage, _impl_.dstchannelid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetHandoverContextResultMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetHandoverContextResultMessage, _impl_.netid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetHandoverContextResultMessage, _impl_.srcchannelid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetHandoverContextResultMessage, _impl_.dstchannelid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetHandoverContextResultMessage, _impl_.context_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::HandoverData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::HandoverData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::HandoverData, _impl_.context_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::HandoverData, _impl_.channeldata_),
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetUnrealObjectRefMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetUnrealObjectRefMessage, _impl_.netguid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetUnrealObjectRefResultMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::GetUnrealObjectRefResultMessage, _impl_.objref_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialEntityState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialEntityState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialEntityState, _impl_.objref_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialEntityState, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialEntityState, _impl_.entitydata_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialChannelData_EntitiesEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialChannelData_EntitiesEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialChannelData_EntitiesEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialChannelData_EntitiesEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialChannelData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::SpatialChannelData, _impl_.entities_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepMovement, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepMovement, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepMovement, _impl_.linearvelocity_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepMovement, _impl_.angularvelocity_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepMovement, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepMovement, _impl_.rotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepMovement, _impl_.bsimulatedphysicsleep_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepMovement, _impl_.brepphysics_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepAttachment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepAttachment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepAttachment, _impl_.attachparent_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepAttachment, _impl_.locationoffset_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepAttachment, _impl_.relativescale_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepAttachment, _impl_.rotationoffset_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepAttachment, _impl_.attachsocket_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepAttachment, _impl_.attachcomponent_),
  1,
  2,
  3,
  4,
  0,
  5,
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.owningconnid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.breplicatemovement_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.localrole_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.remoterole_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.owner_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.bhidden_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.btearoff_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.bcanbedamaged_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.instigator_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.replicatedmovement_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorState, _impl_.attachmentreplication_),
  ~0u,
  4,
  6,
  5,
  9,
  0,
  7,
  8,
  10,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentState, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentState, _impl_.bisactive_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ActorComponentState, _impl_.breplicated_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.removed_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.babsolutelocation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.babsoluterotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.babsolutescale_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.bvisible_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.bshouldbeattached_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.bshouldsnaplocationwhenattached_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.bshouldsnaprotationwhenattached_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.attachparent_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.attachchildren_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.attachsocketname_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.relativelocation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.relativerotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::SceneComponentState, _impl_.relativescale_),
  ~0u,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  1,
  ~0u,
  0,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::unrealpb::FBasedMovementInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FBasedMovementInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FBasedMovementInfo, _impl_.movementbase_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FBasedMovementInfo, _impl_.bonename_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FBasedMovementInfo, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FBasedMovementInfo, _impl_.rotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FBasedMovementInfo, _impl_.bserverhasbasecomponent_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FBasedMovementInfo, _impl_.brelativerotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FBasedMovementInfo, _impl_.bserverhasvelocity_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings, _impl_.setvelocity_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings, _impl_.clampvelocity_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.priority_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.localid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.accumulatedmode_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.instancename_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.starttime_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.currenttime_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.previoustime_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.status_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.settings_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.binlocalspace_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.bneedssimulatedcatchup_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.bsimulatedneedssmoothing_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.bhasrootmotion_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.blendweight_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSource, _impl_.finishvelocityparams_),
  2,
  3,
  4,
  0,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  1,
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSourceGroup, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSourceGroup, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSourceGroup, _impl_.rootmotionsources_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSourceGroup, _impl_.pendingaddrootmotionsources_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSourceGroup, _impl_.bhasadditivesources_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSourceGroup, _impl_.bhasoverridesources_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSourceGroup, _impl_.bhasoverridesourceswithignorezaccumulate_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSourceGroup, _impl_.bisadditivevelocityapplied_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSourceGroup, _impl_.lastaccumulatedsettings_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRootMotionSourceGroup, _impl_.lastpreadditivevelocity_),
  ~0u,
  ~0u,
  1,
  2,
  3,
  4,
  5,
  0,
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.bisactive_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.animmontage_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.position_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.location_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.rotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.movementbase_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.movementbasebonename_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.brelativeposition_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.brelativerotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.authoritativerootmotion_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.acceleration_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FRepRootMotionMontage, _impl_.linearvelocity_),
  9,
  1,
  8,
  2,
  3,
  4,
  0,
  10,
  11,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.rootmotion_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.basedmovement_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.serverlasttransformupdatetimestamp_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.movementmode_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.biscrouched_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.bproxyisjumpforceapplied_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.animrootmotiontranslationscale_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::CharacterState, _impl_.replaylasttransformupdatetimestamp_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ServerMovePacked_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ServerMovePacked_Params, _impl_.bitsnum_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ServerMovePacked_Params, _impl_.packedbits_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ClientMoveResponsePacked_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ClientMoveResponsePacked_Params, _impl_.bitsnum_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::Character_ClientMoveResponsePacked_Params, _impl_.packedbits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_.score_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_.playerid_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_.ping_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerState, _impl_.playername_),
  1,
  2,
  3,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::ControllerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::ControllerState, _impl_.playerstate_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::ControllerState, _impl_.pawn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetLocation_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetLocation_Params, _impl_.newlocation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetLocation_Params, _impl_.newrotation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetRotation_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetRotation_Params, _impl_.newrotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::Controller_ClientSetRotation_Params, _impl_.bresetcamera_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerControllerState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerControllerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerControllerState, _impl_.targetviewrotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerControllerState, _impl_.spawnlocation_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerUpdateCamera_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerUpdateCamera_Params, _impl_.camloc_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerUpdateCamera_Params, _impl_.campitchandyaw_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetHUD_Params, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetHUD_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetHUD_Params, _impl_.hudclassname_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _impl_.actor_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _impl_.blendtime_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _impl_.blendfunction_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _impl_.blendexp_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetViewTarget_Params, _impl_.blockoutgoing_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientEnableNetworkVoice_Params, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientEnableNetworkVoice_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientEnableNetworkVoice_Params, _impl_.benable_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientCapBandwidth_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientCapBandwidth_Params, _impl_.cap_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientRestart_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientRestart_Params, _impl_.pawn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetCameraMode_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientSetCameraMode_Params, _impl_.newcammode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientRetryClientRestart_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientRetryClientRestart_Params, _impl_.pawn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerSetSpectatorLocation_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerSetSpectatorLocation_Params, _impl_.newloc_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerSetSpectatorLocation_Params, _impl_.newrot_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerAcknowledgePossession_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ServerAcknowledgePossession_Params, _impl_.pawn_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientGotoState_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientGotoState_Params, _impl_.newstate_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientReceiveLocalizedMessage_Params, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientReceiveLocalizedMessage_Params, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientReceiveLocalizedMessage_Params, _impl_.switch__),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientReceiveLocalizedMessage_Params, _impl_.relatedplayerstate_1_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientReceiveLocalizedMessage_Params, _impl_.relatedplayerstate_2_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PlayerController_ClientReceiveLocalizedMessage_Params, _impl_.optionalobject_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_.spectatorclassname_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_.gamemodeclassname_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_.replicatedworldtimeseconds_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::GameStateBase, _impl_.breplicatedhasbegunplay_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::unrealpb::PawnState, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PawnState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::PawnState, _impl_.playerstate_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PawnState, _impl_.controller_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::PawnState, _impl_.remoteviewpitch_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.backgoodmove_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.newloc_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.newvel_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.newrot_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.newbase_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.newbasebonename_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.bbaserelativeposition_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.rootmotionsourcecorrection_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.rootmotionrotation_),
  PROTOBUF_FIELD_OFFSET(::unrealpb::FClientAdjustment, _impl_.movementmode_),
  8,
  7,
  1,
  2,
  3,
  4,
  0,
  9,
  5,
  6,
  10,
};
static const ::_pbi::MigrationSchema schemas_unreal_5fcommon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, -1, sizeof(::unrealpb::FVector)},
  { 12, -1, -1, sizeof(::unrealpb::UnrealObjectRef_GuidCachedObject)},
  { 21, 33, -1, sizeof(::unrealpb::UnrealObjectRef)},
  { 39, 47, -1, sizeof(::unrealpb::ActorComponentRef)},
  { 49, -1, -1, sizeof(::unrealpb::RemoteFunctionMessage)},
  { 58, 68, -1, sizeof(::unrealpb::SpawnObjectMessage)},
  { 72, -1, -1, sizeof(::unrealpb::DestroyObjectMessage)},
  { 80, 88, -1, sizeof(::unrealpb::HandoverContext)},
  { 90, -1, -1, sizeof(::unrealpb::GetHandoverContextMessage)},
  { 99, -1, -1, sizeof(::unrealpb::GetHandoverContextResultMessage)},
  { 109, 117, -1, sizeof(::unrealpb::HandoverData)},
  { 119, -1, -1, sizeof(::unrealpb::GetUnrealObjectRefMessage)},
  { 126, -1, -1, sizeof(::unrealpb::GetUnrealObjectRefResultMessage)},
  { 133, 142, -1, sizeof(::unrealpb::SpatialEntityState)},
  { 145, 153, -1, sizeof(::unrealpb::SpatialChannelData_EntitiesEntry_DoNotUse)},
  { 155, -1, -1, sizeof(::unrealpb::SpatialChannelData)},
  { 162, 174, -1, sizeof(::unrealpb::FRepMovement)},
  { 180, 192, -1, sizeof(::unrealpb::FRepAttachment)},
  { 198, 216, -1, sizeof(::unrealpb::ActorState)},
  { 228, 237, -1, sizeof(::unrealpb::ActorComponentState)},
  { 240, 260, -1, sizeof(::unrealpb::SceneComponentState)},
  { 274, 287, -1, sizeof(::unrealpb::FBasedMovementInfo)},
  { 294, 303, -1, sizeof(::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings)},
  { 306, 328, -1, sizeof(::unrealpb::FRootMotionSource)},
  { 344, 358, -1, sizeof(::unrealpb::FRootMotionSourceGroup)},
  { 366, 384, -1, sizeof(::unrealpb::FRepRootMotionMontage)},
  { 396, 410, -1, sizeof(::unrealpb::CharacterState)},
  { 418, -1, -1, sizeof(::unrealpb::Character_ServerMovePacked_Params)},
  { 426, -1, -1, sizeof(::unrealpb::Character_ClientMoveResponsePacked_Params)},
  { 434, 444, -1, sizeof(::unrealpb::PlayerState)},
  { 448, -1, -1, sizeof(::unrealpb::ControllerState)},
  { 456, -1, -1, sizeof(::unrealpb::Controller_ClientSetLocation_Params)},
  { 464, -1, -1, sizeof(::unrealpb::Controller_ClientSetRotation_Params)},
  { 472, 480, -1, sizeof(::unrealpb::PlayerControllerState)},
  { 482, -1, -1, sizeof(::unrealpb::PlayerController_ServerUpdateCamera_Params)},
  { 490, 497, -1, sizeof(::unrealpb::PlayerController_ClientSetHUD_Params)},
  { 498, -1, -1, sizeof(::unrealpb::PlayerController_ClientSetViewTarget_Params)},
  { 509, 516, -1, sizeof(::unrealpb::PlayerController_ClientEnableNetworkVoice_Params)},
  { 517, -1, -1, sizeof(::unrealpb::PlayerController_ClientCapBandwidth_Params)},
  { 524, -1, -1, sizeof(::unrealpb::PlayerController_ClientRestart_Params)},
  { 531, -1, -1, sizeof(::unrealpb::PlayerController_ClientSetCameraMode_Params)},
  { 538, -1, -1, sizeof(::unrealpb::PlayerController_ClientRetryClientRestart_Params)},
  { 545, -1, -1, sizeof(::unrealpb::PlayerController_ServerSetSpectatorLocation_Params)},
  { 553, -1, -1, sizeof(::unrealpb::PlayerController_ServerAcknowledgePossession_Params)},
  { 560, -1, -1, sizeof(::unrealpb::PlayerController_ClientGotoState_Params)},
  { 567, -1, -1, sizeof(::unrealpb::PlayerController_ClientReceiveLocalizedMessage_Params)},
  { 578, 588, -1, sizeof(::unrealpb::GameStateBase)},
  { 592, 601, -1, sizeof(::unrealpb::PawnState)},
  { 604, 621, -1, sizeof(::unrealpb::FClientAdjustment)},
};

static const ::_pb::Message* const file_default_instances_unreal_5fcommon_2eproto[] = {
  &::unrealpb::_FVector_default_instance_._instance,
  &::unrealpb::_UnrealObjectRef_GuidCachedObject_default_instance_._instance,
  &::unrealpb::_UnrealObjectRef_default_instance_._instance,
  &::unrealpb::_ActorComponentRef_default_instance_._instance,
  &::unrealpb::_RemoteFunctionMessage_default_instance_._instance,
  &::unrealpb::_SpawnObjectMessage_default_instance_._instance,
  &::unrealpb::_DestroyObjectMessage_default_instance_._instance,
  &::unrealpb::_HandoverContext_default_instance_._instance,
  &::unrealpb::_GetHandoverContextMessage_default_instance_._instance,
  &::unrealpb::_GetHandoverContextResultMessage_default_instance_._instance,
  &::unrealpb::_HandoverData_default_instance_._instance,
  &::unrealpb::_GetUnrealObjectRefMessage_default_instance_._instance,
  &::unrealpb::_GetUnrealObjectRefResultMessage_default_instance_._instance,
  &::unrealpb::_SpatialEntityState_default_instance_._instance,
  &::unrealpb::_SpatialChannelData_EntitiesEntry_DoNotUse_default_instance_._instance,
  &::unrealpb::_SpatialChannelData_default_instance_._instance,
  &::unrealpb::_FRepMovement_default_instance_._instance,
  &::unrealpb::_FRepAttachment_default_instance_._instance,
  &::unrealpb::_ActorState_default_instance_._instance,
  &::unrealpb::_ActorComponentState_default_instance_._instance,
  &::unrealpb::_SceneComponentState_default_instance_._instance,
  &::unrealpb::_FBasedMovementInfo_default_instance_._instance,
  &::unrealpb::_FRootMotionSource_FRootMotionFinishVelocitySettings_default_instance_._instance,
  &::unrealpb::_FRootMotionSource_default_instance_._instance,
  &::unrealpb::_FRootMotionSourceGroup_default_instance_._instance,
  &::unrealpb::_FRepRootMotionMontage_default_instance_._instance,
  &::unrealpb::_CharacterState_default_instance_._instance,
  &::unrealpb::_Character_ServerMovePacked_Params_default_instance_._instance,
  &::unrealpb::_Character_ClientMoveResponsePacked_Params_default_instance_._instance,
  &::unrealpb::_PlayerState_default_instance_._instance,
  &::unrealpb::_ControllerState_default_instance_._instance,
  &::unrealpb::_Controller_ClientSetLocation_Params_default_instance_._instance,
  &::unrealpb::_Controller_ClientSetRotation_Params_default_instance_._instance,
  &::unrealpb::_PlayerControllerState_default_instance_._instance,
  &::unrealpb::_PlayerController_ServerUpdateCamera_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientSetHUD_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientSetViewTarget_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientEnableNetworkVoice_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientCapBandwidth_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientRestart_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientSetCameraMode_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientRetryClientRestart_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ServerSetSpectatorLocation_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ServerAcknowledgePossession_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientGotoState_Params_default_instance_._instance,
  &::unrealpb::_PlayerController_ClientReceiveLocalizedMessage_Params_default_instance_._instance,
  &::unrealpb::_GameStateBase_default_instance_._instance,
  &::unrealpb::_PawnState_default_instance_._instance,
  &::unrealpb::_FClientAdjustment_default_instance_._instance,
};

const char descriptor_table_protodef_unreal_5fcommon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023unreal_common.proto\022\010unrealpb\032\031google/"
  "protobuf/any.proto\"K\n\007FVector\022\016\n\001x\030\001 \001(\002"
  "H\000\210\001\001\022\016\n\001y\030\002 \001(\002H\001\210\001\001\022\016\n\001z\030\003 \001(\002H\002\210\001\001B\004\n"
  "\002_xB\004\n\002_yB\004\n\002_z\"\344\002\n\017UnrealObjectRef\022\024\n\007n"
  "etGUID\030\001 \001(\rH\000\210\001\001\022;\n\007context\030\002 \003(\0132*.unr"
  "ealpb.UnrealObjectRef.GuidCachedObject\022\031"
  "\n\014netGUIDBunch\030\003 \001(\014H\001\210\001\001\022\031\n\014bunchBitsNu"
  "m\030\004 \001(\rH\002\210\001\001\022\026\n\tclassPath\030\006 \001(\tH\003\210\001\001\022\031\n\014"
  "owningConnId\030\007 \001(\rH\004\210\001\001\032H\n\020GuidCachedObj"
  "ect\022\017\n\007netGUID\030\001 \001(\r\022\020\n\010pathName\030\002 \001(\t\022\021"
  "\n\touterGUID\030\003 \001(\rB\n\n\010_netGUIDB\017\n\r_netGUI"
  "DBunchB\017\n\r_bunchBitsNumB\014\n\n_classPathB\017\n"
  "\r_owningConnId\"p\n\021ActorComponentRef\022-\n\005o"
  "wner\030\001 \001(\0132\031.unrealpb.UnrealObjectRefH\000\210"
  "\001\001\022\025\n\010compName\030\002 \001(\tH\001\210\001\001B\010\n\006_ownerB\013\n\t_"
  "compName\"r\n\025RemoteFunctionMessage\022,\n\ttar"
  "getObj\030\001 \001(\0132\031.unrealpb.UnrealObjectRef\022"
  "\024\n\014functionName\030\002 \001(\t\022\025\n\rparamsPayload\030\003"
  " \001(\014\"\277\001\n\022SpawnObjectMessage\022&\n\003obj\030\001 \001(\013"
  "2\031.unrealpb.UnrealObjectRef\022\026\n\tchannelId"
  "\030\002 \001(\rH\000\210\001\001\022\026\n\tlocalRole\030\003 \001(\rH\001\210\001\001\022(\n\010l"
  "ocation\030\005 \001(\0132\021.unrealpb.FVectorH\002\210\001\001B\014\n"
  "\n_channelIdB\014\n\n_localRoleB\013\n\t_location\"5"
  "\n\024DestroyObjectMessage\022\r\n\005netId\030\001 \001(\r\022\016\n"
  "\006reason\030\002 \001(\r\"e\n\017HandoverContext\022&\n\003obj\030"
  "\001 \001(\0132\031.unrealpb.UnrealObjectRef\022\031\n\014clie"
  "ntConnId\030\002 \001(\rH\000\210\001\001B\017\n\r_clientConnId\"V\n\031"
  "GetHandoverContextMessage\022\r\n\005netId\030\001 \001(\r"
  "\022\024\n\014srcChannelId\030\002 \001(\r\022\024\n\014dstChannelId\030\003"
  " \001(\r\"\210\001\n\037GetHandoverContextResultMessage"
  "\022\r\n\005netId\030\001 \001(\r\022\024\n\014srcChannelId\030\002 \001(\r\022\024\n"
  "\014dstChannelId\030\003 \001(\r\022*\n\007context\030\004 \003(\0132\031.u"
  "nrealpb.HandoverContext\"z\n\014HandoverData\022"
  "*\n\007context\030\001 \003(\0132\031.unrealpb.HandoverCont"
  "ext\022.\n\013channelData\030\002 \001(\0132\024.google.protob"
  "uf.AnyH\000\210\001\001B\016\n\014_channelData\",\n\031GetUnreal"
  "ObjectRefMessage\022\017\n\007netGUID\030\001 \003(\r\"L\n\037Get"
  "UnrealObjectRefResultMessage\022)\n\006objRef\030\001"
  " \003(\0132\031.unrealpb.UnrealObjectRef\"\216\001\n\022Spat"
  "ialEntityState\022)\n\006objRef\030\001 \001(\0132\031.unrealp"
  "b.UnrealObjectRef\022\017\n\007removed\030\002 \001(\010\022-\n\nen"
  "tityData\030\003 \001(\0132\024.google.protobuf.AnyH\000\210\001"
  "\001B\r\n\013_entityData\"\241\001\n\022SpatialChannelData\022"
  "<\n\010entities\030\001 \003(\0132*.unrealpb.SpatialChan"
  "nelData.EntitiesEntry\032M\n\rEntitiesEntry\022\013"
  "\n\003key\030\001 \001(\r\022+\n\005value\030\002 \001(\0132\034.unrealpb.Sp"
  "atialEntityState:\0028\001\"\354\002\n\014FRepMovement\022.\n"
  "\016linearVelocity\030\001 \001(\0132\021.unrealpb.FVector"
  "H\000\210\001\001\022/\n\017angularVelocity\030\002 \001(\0132\021.unrealp"
  "b.FVectorH\001\210\001\001\022(\n\010location\030\003 \001(\0132\021.unrea"
  "lpb.FVectorH\002\210\001\001\022(\n\010rotation\030\004 \001(\0132\021.unr"
  "ealpb.FVectorH\003\210\001\001\022\"\n\025bSimulatedPhysicSl"
  "eep\030\005 \001(\010H\004\210\001\001\022\030\n\013bRepPhysics\030\006 \001(\010H\005\210\001\001"
  "B\021\n\017_linearVelocityB\022\n\020_angularVelocityB"
  "\013\n\t_locationB\013\n\t_rotationB\030\n\026_bSimulated"
  "PhysicSleepB\016\n\014_bRepPhysics\"\231\003\n\016FRepAtta"
  "chment\0224\n\014attachParent\030\001 \001(\0132\031.unrealpb."
  "UnrealObjectRefH\000\210\001\001\022.\n\016locationOffset\030\002"
  " \001(\0132\021.unrealpb.FVectorH\001\210\001\001\022-\n\rrelative"
  "Scale\030\003 \001(\0132\021.unrealpb.FVectorH\002\210\001\001\022.\n\016r"
  "otationOffset\030\004 \001(\0132\021.unrealpb.FVectorH\003"
  "\210\001\001\022\031\n\014attachSocket\030\005 \001(\tH\004\210\001\001\0229\n\017attach"
  "Component\030\006 \001(\0132\033.unrealpb.ActorComponen"
  "tRefH\005\210\001\001B\017\n\r_attachParentB\021\n\017_locationO"
  "ffsetB\020\n\016_relativeScaleB\021\n\017_rotationOffs"
  "etB\017\n\r_attachSocketB\022\n\020_attachComponent\""
  "\347\004\n\nActorState\022\017\n\007removed\030\001 \001(\010\022\031\n\014ownin"
  "gConnId\030\002 \001(\rH\000\210\001\001\022\037\n\022bReplicateMovement"
  "\030\003 \001(\010H\001\210\001\001\022\026\n\tlocalRole\030\004 \001(\rH\002\210\001\001\022\027\n\nr"
  "emoteRole\030\005 \001(\rH\003\210\001\001\022-\n\005owner\030\006 \001(\0132\031.un"
  "realpb.UnrealObjectRefH\004\210\001\001\022\024\n\007bHidden\030\007"
  " \001(\010H\005\210\001\001\022\025\n\010bTearOff\030\010 \001(\010H\006\210\001\001\022\032\n\rbCan"
  "BeDamaged\030\t \001(\010H\007\210\001\001\0222\n\ninstigator\030\n \001(\013"
  "2\031.unrealpb.UnrealObjectRefH\010\210\001\001\0227\n\022repl"
  "icatedMovement\030\013 \001(\0132\026.unrealpb.FRepMove"
  "mentH\t\210\001\001\022<\n\025attachmentReplication\030\014 \001(\013"
  "2\030.unrealpb.FRepAttachmentH\n\210\001\001B\017\n\r_owni"
  "ngConnIdB\025\n\023_bReplicateMovementB\014\n\n_loca"
  "lRoleB\r\n\013_remoteRoleB\010\n\006_ownerB\n\n\010_bHidd"
  "enB\013\n\t_bTearOffB\020\n\016_bCanBeDamagedB\r\n\013_in"
  "stigatorB\025\n\023_replicatedMovementB\030\n\026_atta"
  "chmentReplication\"v\n\023ActorComponentState"
  "\022\017\n\007removed\030\001 \001(\010\022\026\n\tbIsActive\030\002 \001(\010H\000\210\001"
  "\001\022\030\n\013bReplicated\030\003 \001(\010H\001\210\001\001B\014\n\n_bIsActiv"
  "eB\016\n\014_bReplicated\"\301\006\n\023SceneComponentStat"
  "e\022\017\n\007removed\030\001 \001(\010\022\036\n\021bAbsoluteLocation\030"
  "\002 \001(\010H\000\210\001\001\022\036\n\021bAbsoluteRotation\030\003 \001(\010H\001\210"
  "\001\001\022\033\n\016bAbsoluteScale\030\004 \001(\010H\002\210\001\001\022\025\n\010bVisi"
  "ble\030\005 \001(\010H\003\210\001\001\022\036\n\021bShouldBeAttached\030\006 \001("
  "\010H\004\210\001\001\022,\n\037bShouldSnapLocationWhenAttache"
  "d\030\007 \001(\010H\005\210\001\001\022,\n\037bShouldSnapRotationWhenA"
  "ttached\030\010 \001(\010H\006\210\001\001\0226\n\014attachParent\030\t \001(\013"
  "2\033.unrealpb.ActorComponentRefH\007\210\001\001\0223\n\016at"
  "tachChildren\030\n \003(\0132\033.unrealpb.ActorCompo"
  "nentRef\022\035\n\020attachSocketName\030\013 \001(\tH\010\210\001\001\0220"
  "\n\020relativeLocation\030\014 \001(\0132\021.unrealpb.FVec"
  "torH\t\210\001\001\0220\n\020relativeRotation\030\r \001(\0132\021.unr"
  "ealpb.FVectorH\n\210\001\001\022-\n\rrelativeScale\030\016 \001("
  "\0132\021.unrealpb.FVectorH\013\210\001\001B\024\n\022_bAbsoluteL"
  "ocationB\024\n\022_bAbsoluteRotationB\021\n\017_bAbsol"
  "uteScaleB\013\n\t_bVisibleB\024\n\022_bShouldBeAttac"
  "hedB\"\n _bShouldSnapLocationWhenAttachedB"
  "\"\n _bShouldSnapRotationWhenAttachedB\017\n\r_"
  "attachParentB\023\n\021_attachSocketNameB\023\n\021_re"
  "lativeLocationB\023\n\021_relativeRotationB\020\n\016_"
  "relativeScale\"\237\003\n\022FBasedMovementInfo\0226\n\014"
  "movementBase\030\001 \001(\0132\033.unrealpb.ActorCompo"
  "nentRefH\000\210\001\001\022\025\n\010boneName\030\002 \001(\tH\001\210\001\001\022(\n\010l"
  "ocation\030\003 \001(\0132\021.unrealpb.FVectorH\002\210\001\001\022(\n"
  "\010rotation\030\004 \001(\0132\021.unrealpb.FVectorH\003\210\001\001\022"
  "$\n\027bServerHasBaseComponent\030\005 \001(\010H\004\210\001\001\022\036\n"
  "\021bRelativeRotation\030\006 \001(\010H\005\210\001\001\022\037\n\022bServer"
  "HasVelocity\030\007 \001(\010H\006\210\001\001B\017\n\r_movementBaseB"
  "\013\n\t_boneNameB\013\n\t_locationB\013\n\t_rotationB\032"
  "\n\030_bServerHasBaseComponentB\024\n\022_bRelative"
  "RotationB\025\n\023_bServerHasVelocity\"\317\007\n\021FRoo"
  "tMotionSource\022\025\n\010priority\030\001 \001(\rH\000\210\001\001\022\024\n\007"
  "localId\030\002 \001(\rH\001\210\001\001\022\034\n\017accumulatedMode\030\003 "
  "\001(\rH\002\210\001\001\022\031\n\014instanceName\030\004 \001(\tH\003\210\001\001\022\026\n\ts"
  "tartTime\030\005 \001(\002H\004\210\001\001\022\030\n\013currentTime\030\006 \001(\002"
  "H\005\210\001\001\022\031\n\014previousTime\030\007 \001(\002H\006\210\001\001\022\025\n\010dura"
  "tion\030\010 \001(\002H\007\210\001\001\022\023\n\006status\030\t \001(\rH\010\210\001\001\022\025\n\010"
  "settings\030\n \001(\rH\t\210\001\001\022\032\n\rbInLocalSpace\030\013 \001"
  "(\010H\n\210\001\001\022#\n\026bNeedsSimulatedCatchup\030\014 \001(\010H"
  "\013\210\001\001\022%\n\030bSimulatedNeedsSmoothing\030\r \001(\010H\014"
  "\210\001\001\022\033\n\016bHasRootMotion\030\016 \001(\010H\r\210\001\001\022\030\n\013blen"
  "dWeight\030\017 \001(\002H\016\210\001\001\022`\n\024finishVelocityPara"
  "ms\030\020 \001(\0132=.unrealpb.FRootMotionSource.FR"
  "ootMotionFinishVelocitySettingsH\017\210\001\001\032\252\001\n"
  "!FRootMotionFinishVelocitySettings\022\021\n\004mo"
  "de\030\001 \001(\rH\000\210\001\001\022+\n\013setVelocity\030\002 \001(\0132\021.unr"
  "ealpb.FVectorH\001\210\001\001\022\032\n\rclampVelocity\030\003 \001("
  "\002H\002\210\001\001B\007\n\005_modeB\016\n\014_setVelocityB\020\n\016_clam"
  "pVelocityB\013\n\t_priorityB\n\n\010_localIdB\022\n\020_a"
  "ccumulatedModeB\017\n\r_instanceNameB\014\n\n_star"
  "tTimeB\016\n\014_currentTimeB\017\n\r_previousTimeB\013"
  "\n\t_durationB\t\n\007_statusB\013\n\t_settingsB\020\n\016_"
  "bInLocalSpaceB\031\n\027_bNeedsSimulatedCatchup"
  "B\033\n\031_bSimulatedNeedsSmoothingB\021\n\017_bHasRo"
  "otMotionB\016\n\014_blendWeightB\027\n\025_finishVeloc"
  "ityParams\"\311\004\n\026FRootMotionSourceGroup\0226\n\021"
  "rootMotionSources\030\001 \003(\0132\033.unrealpb.FRoot"
  "MotionSource\022@\n\033pendingAddRootMotionSour"
  "ces\030\002 \003(\0132\033.unrealpb.FRootMotionSource\022 "
  "\n\023bHasAdditiveSources\030\003 \001(\010H\000\210\001\001\022 \n\023bHas"
  "OverrideSources\030\004 \001(\010H\001\210\001\001\0225\n(bHasOverri"
  "deSourcesWithIgnoreZAccumulate\030\005 \001(\010H\002\210\001"
  "\001\022\'\n\032bIsAdditiveVelocityApplied\030\006 \001(\010H\003\210"
  "\001\001\022$\n\027lastAccumulatedSettings\030\007 \001(\rH\004\210\001\001"
  "\0227\n\027lastPreAdditiveVelocity\030\010 \001(\0132\021.unre"
  "alpb.FVectorH\005\210\001\001B\026\n\024_bHasAdditiveSource"
  "sB\026\n\024_bHasOverrideSourcesB+\n)_bHasOverri"
  "deSourcesWithIgnoreZAccumulateB\035\n\033_bIsAd"
  "ditiveVelocityAppliedB\032\n\030_lastAccumulate"
  "dSettingsB\032\n\030_lastPreAdditiveVelocity\"\353\005"
  "\n\025FRepRootMotionMontage\022\026\n\tbIsActive\030\001 \001"
  "(\010H\000\210\001\001\0223\n\013animMontage\030\002 \001(\0132\031.unrealpb."
  "UnrealObjectRefH\001\210\001\001\022\025\n\010position\030\003 \001(\002H\002"
  "\210\001\001\022(\n\010location\030\004 \001(\0132\021.unrealpb.FVector"
  "H\003\210\001\001\022(\n\010rotation\030\005 \001(\0132\021.unrealpb.FVect"
  "orH\004\210\001\001\0226\n\014movementBase\030\006 \001(\0132\033.unrealpb"
  ".ActorComponentRefH\005\210\001\001\022!\n\024movementBaseB"
  "oneName\030\007 \001(\tH\006\210\001\001\022\036\n\021bRelativePosition\030"
  "\010 \001(\010H\007\210\001\001\022\036\n\021bRelativeRotation\030\t \001(\010H\010\210"
  "\001\001\022F\n\027authoritativeRootMotion\030\n \001(\0132 .un"
  "realpb.FRootMotionSourceGroupH\t\210\001\001\022,\n\014ac"
  "celeration\030\013 \001(\0132\021.unrealpb.FVectorH\n\210\001\001"
  "\022.\n\016linearVelocity\030\014 \001(\0132\021.unrealpb.FVec"
  "torH\013\210\001\001B\014\n\n_bIsActiveB\016\n\014_animMontageB\013"
  "\n\t_positionB\013\n\t_locationB\013\n\t_rotationB\017\n"
  "\r_movementBaseB\027\n\025_movementBaseBoneNameB"
  "\024\n\022_bRelativePositionB\024\n\022_bRelativeRotat"
  "ionB\032\n\030_authoritativeRootMotionB\017\n\r_acce"
  "lerationB\021\n\017_linearVelocity\"\277\004\n\016Characte"
  "rState\0228\n\nrootMotion\030\002 \001(\0132\037.unrealpb.FR"
  "epRootMotionMontageH\000\210\001\001\0228\n\rbasedMovemen"
  "t\030\003 \001(\0132\034.unrealpb.FBasedMovementInfoH\001\210"
  "\001\001\022/\n\"serverLastTransformUpdateTimeStamp"
  "\030\004 \001(\002H\002\210\001\001\022\031\n\014movementMode\030\005 \001(\rH\003\210\001\001\022\030"
  "\n\013bIsCrouched\030\006 \001(\010H\004\210\001\001\022%\n\030bProxyIsJump"
  "ForceApplied\030\007 \001(\010H\005\210\001\001\022+\n\036animRootMotio"
  "nTranslationScale\030\010 \001(\002H\006\210\001\001\022/\n\"replayLa"
  "stTransformUpdateTimeStamp\030\t \001(\002H\007\210\001\001B\r\n"
  "\013_rootMotionB\020\n\016_basedMovementB%\n#_serve"
  "rLastTransformUpdateTimeStampB\017\n\r_moveme"
  "ntModeB\016\n\014_bIsCrouchedB\033\n\031_bProxyIsJumpF"
  "orceAppliedB!\n\037_animRootMotionTranslatio"
  "nScaleB%\n#_replayLastTransformUpdateTime"
  "Stamp\"H\n!Character_ServerMovePacked_Para"
  "ms\022\017\n\007bitsNum\030\001 \001(\r\022\022\n\npackedBits\030\002 \001(\014\""
  "P\n)Character_ClientMoveResponsePacked_Pa"
  "rams\022\017\n\007bitsNum\030\001 \001(\r\022\022\n\npackedBits\030\002 \001("
  "\014\"\223\001\n\013PlayerState\022\022\n\005score\030\002 \001(\002H\000\210\001\001\022\025\n"
  "\010playerId\030\003 \001(\005H\001\210\001\001\022\021\n\004ping\030\004 \001(\rH\002\210\001\001\022"
  "\027\n\nplayerName\030\005 \001(\tH\003\210\001\001B\010\n\006_scoreB\013\n\t_p"
  "layerIdB\007\n\005_pingB\r\n\013_playerName\"j\n\017Contr"
  "ollerState\022.\n\013playerState\030\002 \001(\0132\031.unreal"
  "pb.UnrealObjectRef\022\'\n\004pawn\030\003 \001(\0132\031.unrea"
  "lpb.UnrealObjectRef\"u\n#Controller_Client"
  "SetLocation_Params\022&\n\013newLocation\030\001 \001(\0132"
  "\021.unrealpb.FVector\022&\n\013newRotation\030\002 \001(\0132"
  "\021.unrealpb.FVector\"c\n#Controller_ClientS"
  "etRotation_Params\022&\n\013newRotation\030\001 \001(\0132\021"
  ".unrealpb.FVector\022\024\n\014bResetCamera\030\002 \001(\010\""
  "\243\001\n\025PlayerControllerState\0222\n\022targetViewR"
  "otation\030\002 \001(\0132\021.unrealpb.FVectorH\000\210\001\001\022-\n"
  "\rspawnLocation\030\003 \001(\0132\021.unrealpb.FVectorH"
  "\001\210\001\001B\025\n\023_targetViewRotationB\020\n\016_spawnLoc"
  "ation\"g\n*PlayerController_ServerUpdateCa"
  "mera_Params\022!\n\006camLoc\030\001 \001(\0132\021.unrealpb.F"
  "Vector\022\026\n\016camPitchAndYaw\030\002 \001(\005\"R\n$Player"
  "Controller_ClientSetHUD_Params\022\031\n\014hudCla"
  "ssName\030\001 \001(\tH\000\210\001\001B\017\n\r_hudClassName\"\252\001\n+P"
  "layerController_ClientSetViewTarget_Para"
  "ms\022(\n\005actor\030\001 \001(\0132\031.unrealpb.UnrealObjec"
  "tRef\022\021\n\tblendTime\030\002 \001(\002\022\025\n\rblendFunction"
  "\030\003 \001(\r\022\020\n\010blendExp\030\004 \001(\002\022\025\n\rbLockOutgoin"
  "g\030\005 \001(\010\"T\n0PlayerController_ClientEnable"
  "NetworkVoice_Params\022\024\n\007bEnable\030\001 \001(\010H\000\210\001"
  "\001B\n\n\010_bEnable\"9\n*PlayerController_Client"
  "CapBandwidth_Params\022\013\n\003cap\030\001 \001(\005\"P\n%Play"
  "erController_ClientRestart_Params\022\'\n\004paw"
  "n\030\001 \001(\0132\031.unrealpb.UnrealObjectRef\"A\n+Pl"
  "ayerController_ClientSetCameraMode_Param"
  "s\022\022\n\nnewCamMode\030\001 \001(\t\"[\n0PlayerControlle"
  "r_ClientRetryClientRestart_Params\022\'\n\004paw"
  "n\030\001 \001(\0132\031.unrealpb.UnrealObjectRef\"z\n2Pl"
  "ayerController_ServerSetSpectatorLocatio"
  "n_Params\022!\n\006newLoc\030\001 \001(\0132\021.unrealpb.FVec"
  "tor\022!\n\006newRot\030\002 \001(\0132\021.unrealpb.FVector\"^"
  "\n3PlayerController_ServerAcknowledgePoss"
  "ession_Params\022\'\n\004pawn\030\001 \001(\0132\031.unrealpb.U"
  "nrealObjectRef\";\n\'PlayerController_Clien"
  "tGotoState_Params\022\020\n\010newState\030\001 \001(\t\"\375\001\n5"
  "PlayerController_ClientReceiveLocalizedM"
  "essage_Params\022\017\n\007message\030\001 \001(\t\022\016\n\006switch"
  "\030\002 \001(\005\0227\n\024relatedPlayerState_1\030\003 \001(\0132\031.u"
  "nrealpb.UnrealObjectRef\0227\n\024relatedPlayer"
  "State_2\030\004 \001(\0132\031.unrealpb.UnrealObjectRef"
  "\0221\n\016optionalObject\030\005 \001(\0132\031.unrealpb.Unre"
  "alObjectRef\"\207\002\n\rGameStateBase\022\037\n\022spectat"
  "orClassName\030\002 \001(\tH\000\210\001\001\022\036\n\021gameModeClassN"
  "ame\030\003 \001(\tH\001\210\001\001\022\'\n\032replicatedWorldTimeSec"
  "onds\030\004 \001(\002H\002\210\001\001\022$\n\027bReplicatedHasBegunPl"
  "ay\030\005 \001(\010H\003\210\001\001B\025\n\023_spectatorClassNameB\024\n\022"
  "_gameModeClassNameB\035\n\033_replicatedWorldTi"
  "meSecondsB\032\n\030_bReplicatedHasBegunPlay\"\234\001"
  "\n\tPawnState\022.\n\013playerState\030\001 \001(\0132\031.unrea"
  "lpb.UnrealObjectRef\022-\n\ncontroller\030\002 \001(\0132"
  "\031.unrealpb.UnrealObjectRef\022\034\n\017remoteView"
  "Pitch\030\003 \001(\rH\000\210\001\001B\022\n\020_remoteViewPitch\"\214\005\n"
  "\021FClientAdjustment\022\031\n\014bAckGoodMove\030\001 \001(\010"
  "H\000\210\001\001\022\026\n\ttimeStamp\030\002 \001(\002H\001\210\001\001\022&\n\006newLoc\030"
  "\003 \001(\0132\021.unrealpb.FVectorH\002\210\001\001\022&\n\006newVel\030"
  "\004 \001(\0132\021.unrealpb.FVectorH\003\210\001\001\022&\n\006newRot\030"
  "\005 \001(\0132\021.unrealpb.FVectorH\004\210\001\001\022/\n\007newBase"
  "\030\006 \001(\0132\031.unrealpb.UnrealObjectRefH\005\210\001\001\022\034"
  "\n\017newBaseBoneName\030\007 \001(\tH\006\210\001\001\022\"\n\025bBaseRel"
  "ativePosition\030\010 \001(\010H\007\210\001\001\022I\n\032rootMotionSo"
  "urceCorrection\030\t \001(\0132 .unrealpb.FRootMot"
  "ionSourceGroupH\010\210\001\001\0222\n\022rootMotionRotatio"
  "n\030\n \001(\0132\021.unrealpb.FVectorH\t\210\001\001\022\031\n\014movem"
  "entMode\030\013 \001(\rH\n\210\001\001B\017\n\r_bAckGoodMoveB\014\n\n_"
  "timeStampB\t\n\007_newLocB\t\n\007_newVelB\t\n\007_newR"
  "otB\n\n\010_newBaseB\022\n\020_newBaseBoneNameB\030\n\026_b"
  "BaseRelativePositionB\035\n\033_rootMotionSourc"
  "eCorrectionB\025\n\023_rootMotionRotationB\017\n\r_m"
  "ovementMode*\272\001\n\013MessageType\022\013\n\007INVALID\020\000"
  "\022\r\n\tLOW_LEVEL\020d\022\007\n\003ANY\020e\022\007\n\003RPC\020f\022\t\n\005SPA"
  "WN\020g\022\013\n\007DESTROY\020h\022\024\n\020HANDOVER_CONTEXT\020i\022"
  "\031\n\025GET_UNREAL_OBJECT_REF\020j\022\032\n\025SERVER_PLA"
  "YER_SPAWNED\020\311\001\022\030\n\023SERVER_PLAYER_LEAVE\020\312\001"
  "*\251\001\n\020UnrealObjectType\022\017\n\013UOT_Unknown\020\000\022\021"
  "\n\rUOT_GameState\020\001\022\r\n\tUOT_Actor\020\002\022\014\n\010UOT_"
  "Pawn\020\003\022\021\n\rUOT_Character\020\004\022\023\n\017UOT_PlayerS"
  "tate\020\005\022\022\n\016UOT_Controller\020\006\022\030\n\024UOT_Player"
  "Controller\020\007B.Z,github.com/metaworking/c"
  "hanneld/pkg/unrealpbb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_unreal_5fcommon_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2fany_2eproto,
};
static ::_pbi::once_flag descriptor_table_unreal_5fcommon_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_unreal_5fcommon_2eproto = {
    false, false, 11108, descriptor_table_protodef_unreal_5fcommon_2eproto,
    "unreal_common.proto",
    &descriptor_table_unreal_5fcommon_2eproto_once, descriptor_table_unreal_5fcommon_2eproto_deps, 1, 49,
    schemas_unreal_5fcommon_2eproto, file_default_instances_unreal_5fcommon_2eproto, TableStruct_unreal_5fcommon_2eproto::offsets,
    file_level_metadata_unreal_5fcommon_2eproto, file_level_enum_descriptors_unreal_5fcommon_2eproto,
    file_level_service_descriptors_unreal_5fcommon_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_unreal_5fcommon_2eproto_getter() {
  return &descriptor_table_unreal_5fcommon_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_unreal_5fcommon_2eproto(&descriptor_table_unreal_5fcommon_2eproto);
namespace unrealpb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_unreal_5fcommon_2eproto);
  return file_level_enum_descriptors_unreal_5fcommon_2eproto[0];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 201:
    case 202:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UnrealObjectType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_unreal_5fcommon_2eproto);
  return file_level_enum_descriptors_unreal_5fcommon_2eproto[1];
}
bool UnrealObjectType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class FVector::_Internal {
 public:
  using HasBits = decltype(std::declval<FVector>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

FVector::FVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.FVector)
}
FVector::FVector(const FVector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FVector* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.FVector)
}

inline void FVector::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
  };
}

FVector::~FVector() {
  // @@protoc_insertion_point(destructor:unrealpb.FVector)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FVector::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FVector::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FVector::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.FVector)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.z_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FVector::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FVector::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.FVector)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // optional float z = 3;
  if (_internal_has_z()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.FVector)
  return target;
}

size_t FVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.FVector)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FVector::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FVector::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FVector::GetClassData() const { return &_class_data_; }


void FVector::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FVector*>(&to_msg);
  auto& from = static_cast<const FVector&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.FVector)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.z_ = from._impl_.z_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FVector::CopyFrom(const FVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.FVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FVector::IsInitialized() const {
  return true;
}

void FVector::InternalSwap(FVector* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FVector, _impl_.z_)
      + sizeof(FVector::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(FVector, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FVector::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[0]);
}

// ===================================================================

class UnrealObjectRef_GuidCachedObject::_Internal {
 public:
};

UnrealObjectRef_GuidCachedObject::UnrealObjectRef_GuidCachedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.UnrealObjectRef.GuidCachedObject)
}
UnrealObjectRef_GuidCachedObject::UnrealObjectRef_GuidCachedObject(const UnrealObjectRef_GuidCachedObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnrealObjectRef_GuidCachedObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pathname_){}
    , decltype(_impl_.netguid_){}
    , decltype(_impl_.outerguid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.pathname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pathname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pathname().empty()) {
    _this->_impl_.pathname_.Set(from._internal_pathname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.netguid_, &from._impl_.netguid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.outerguid_) -
    reinterpret_cast<char*>(&_impl_.netguid_)) + sizeof(_impl_.outerguid_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.UnrealObjectRef.GuidCachedObject)
}

inline void UnrealObjectRef_GuidCachedObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pathname_){}
    , decltype(_impl_.netguid_){0u}
    , decltype(_impl_.outerguid_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.pathname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pathname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnrealObjectRef_GuidCachedObject::~UnrealObjectRef_GuidCachedObject() {
  // @@protoc_insertion_point(destructor:unrealpb.UnrealObjectRef.GuidCachedObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnrealObjectRef_GuidCachedObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pathname_.Destroy();
}

void UnrealObjectRef_GuidCachedObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnrealObjectRef_GuidCachedObject::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.UnrealObjectRef.GuidCachedObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pathname_.ClearToEmpty();
  ::memset(&_impl_.netguid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.outerguid_) -
      reinterpret_cast<char*>(&_impl_.netguid_)) + sizeof(_impl_.outerguid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnrealObjectRef_GuidCachedObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 netGUID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.netguid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string pathName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_pathname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.UnrealObjectRef.GuidCachedObject.pathName"));
        } else
          goto handle_unusual;
        continue;
      // uint32 outerGUID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.outerguid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnrealObjectRef_GuidCachedObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.UnrealObjectRef.GuidCachedObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 netGUID = 1;
  if (this->_internal_netguid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_netguid(), target);
  }

  // string pathName = 2;
  if (!this->_internal_pathname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pathname().data(), static_cast<int>(this->_internal_pathname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.UnrealObjectRef.GuidCachedObject.pathName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_pathname(), target);
  }

  // uint32 outerGUID = 3;
  if (this->_internal_outerguid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_outerguid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.UnrealObjectRef.GuidCachedObject)
  return target;
}

size_t UnrealObjectRef_GuidCachedObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.UnrealObjectRef.GuidCachedObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string pathName = 2;
  if (!this->_internal_pathname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_pathname());
  }

  // uint32 netGUID = 1;
  if (this->_internal_netguid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_netguid());
  }

  // uint32 outerGUID = 3;
  if (this->_internal_outerguid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_outerguid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnrealObjectRef_GuidCachedObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnrealObjectRef_GuidCachedObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnrealObjectRef_GuidCachedObject::GetClassData() const { return &_class_data_; }


void UnrealObjectRef_GuidCachedObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnrealObjectRef_GuidCachedObject*>(&to_msg);
  auto& from = static_cast<const UnrealObjectRef_GuidCachedObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.UnrealObjectRef.GuidCachedObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_pathname().empty()) {
    _this->_internal_set_pathname(from._internal_pathname());
  }
  if (from._internal_netguid() != 0) {
    _this->_internal_set_netguid(from._internal_netguid());
  }
  if (from._internal_outerguid() != 0) {
    _this->_internal_set_outerguid(from._internal_outerguid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnrealObjectRef_GuidCachedObject::CopyFrom(const UnrealObjectRef_GuidCachedObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.UnrealObjectRef.GuidCachedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnrealObjectRef_GuidCachedObject::IsInitialized() const {
  return true;
}

void UnrealObjectRef_GuidCachedObject::InternalSwap(UnrealObjectRef_GuidCachedObject* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pathname_, lhs_arena,
      &other->_impl_.pathname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnrealObjectRef_GuidCachedObject, _impl_.outerguid_)
      + sizeof(UnrealObjectRef_GuidCachedObject::_impl_.outerguid_)
      - PROTOBUF_FIELD_OFFSET(UnrealObjectRef_GuidCachedObject, _impl_.netguid_)>(
          reinterpret_cast<char*>(&_impl_.netguid_),
          reinterpret_cast<char*>(&other->_impl_.netguid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UnrealObjectRef_GuidCachedObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[1]);
}

// ===================================================================

class UnrealObjectRef::_Internal {
 public:
  using HasBits = decltype(std::declval<UnrealObjectRef>()._impl_._has_bits_);
  static void set_has_netguid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_netguidbunch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bunchbitsnum(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_classpath(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_owningconnid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

UnrealObjectRef::UnrealObjectRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.UnrealObjectRef)
}
UnrealObjectRef::UnrealObjectRef(const UnrealObjectRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UnrealObjectRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.context_){from._impl_.context_}
    , decltype(_impl_.netguidbunch_){}
    , decltype(_impl_.classpath_){}
    , decltype(_impl_.netguid_){}
    , decltype(_impl_.bunchbitsnum_){}
    , decltype(_impl_.owningconnid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.netguidbunch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.netguidbunch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_netguidbunch()) {
    _this->_impl_.netguidbunch_.Set(from._internal_netguidbunch(), 
      _this->GetArenaForAllocation());
  }
  _impl_.classpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.classpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_classpath()) {
    _this->_impl_.classpath_.Set(from._internal_classpath(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.netguid_, &from._impl_.netguid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.owningconnid_) -
    reinterpret_cast<char*>(&_impl_.netguid_)) + sizeof(_impl_.owningconnid_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.UnrealObjectRef)
}

inline void UnrealObjectRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.context_){arena}
    , decltype(_impl_.netguidbunch_){}
    , decltype(_impl_.classpath_){}
    , decltype(_impl_.netguid_){0u}
    , decltype(_impl_.bunchbitsnum_){0u}
    , decltype(_impl_.owningconnid_){0u}
  };
  _impl_.netguidbunch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.netguidbunch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.classpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.classpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UnrealObjectRef::~UnrealObjectRef() {
  // @@protoc_insertion_point(destructor:unrealpb.UnrealObjectRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UnrealObjectRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.context_.~RepeatedPtrField();
  _impl_.netguidbunch_.Destroy();
  _impl_.classpath_.Destroy();
}

void UnrealObjectRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UnrealObjectRef::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.UnrealObjectRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.context_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.netguidbunch_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.classpath_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.netguid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.owningconnid_) -
        reinterpret_cast<char*>(&_impl_.netguid_)) + sizeof(_impl_.owningconnid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UnrealObjectRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 netGUID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_netguid(&has_bits);
          _impl_.netguid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .unrealpb.UnrealObjectRef.GuidCachedObject context = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_context(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bytes netGUIDBunch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_netguidbunch();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bunchBitsNum = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bunchbitsnum(&has_bits);
          _impl_.bunchbitsnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string classPath = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_classpath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.UnrealObjectRef.classPath"));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 owningConnId = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_owningconnid(&has_bits);
          _impl_.owningconnid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UnrealObjectRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.UnrealObjectRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 netGUID = 1;
  if (_internal_has_netguid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_netguid(), target);
  }

  // repeated .unrealpb.UnrealObjectRef.GuidCachedObject context = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_context_size()); i < n; i++) {
    const auto& repfield = this->_internal_context(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bytes netGUIDBunch = 3;
  if (_internal_has_netguidbunch()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_netguidbunch(), target);
  }

  // optional uint32 bunchBitsNum = 4;
  if (_internal_has_bunchbitsnum()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_bunchbitsnum(), target);
  }

  // optional string classPath = 6;
  if (_internal_has_classpath()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_classpath().data(), static_cast<int>(this->_internal_classpath().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.UnrealObjectRef.classPath");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_classpath(), target);
  }

  // optional uint32 owningConnId = 7;
  if (_internal_has_owningconnid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_owningconnid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.UnrealObjectRef)
  return target;
}

size_t UnrealObjectRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.UnrealObjectRef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unrealpb.UnrealObjectRef.GuidCachedObject context = 2;
  total_size += 1UL * this->_internal_context_size();
  for (const auto& msg : this->_impl_.context_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes netGUIDBunch = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_netguidbunch());
    }

    // optional string classPath = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_classpath());
    }

    // optional uint32 netGUID = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_netguid());
    }

    // optional uint32 bunchBitsNum = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bunchbitsnum());
    }

    // optional uint32 owningConnId = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_owningconnid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UnrealObjectRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UnrealObjectRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UnrealObjectRef::GetClassData() const { return &_class_data_; }


void UnrealObjectRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UnrealObjectRef*>(&to_msg);
  auto& from = static_cast<const UnrealObjectRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.UnrealObjectRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.context_.MergeFrom(from._impl_.context_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_netguidbunch(from._internal_netguidbunch());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_classpath(from._internal_classpath());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.netguid_ = from._impl_.netguid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bunchbitsnum_ = from._impl_.bunchbitsnum_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.owningconnid_ = from._impl_.owningconnid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UnrealObjectRef::CopyFrom(const UnrealObjectRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.UnrealObjectRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnrealObjectRef::IsInitialized() const {
  return true;
}

void UnrealObjectRef::InternalSwap(UnrealObjectRef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.context_.InternalSwap(&other->_impl_.context_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.netguidbunch_, lhs_arena,
      &other->_impl_.netguidbunch_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.classpath_, lhs_arena,
      &other->_impl_.classpath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UnrealObjectRef, _impl_.owningconnid_)
      + sizeof(UnrealObjectRef::_impl_.owningconnid_)
      - PROTOBUF_FIELD_OFFSET(UnrealObjectRef, _impl_.netguid_)>(
          reinterpret_cast<char*>(&_impl_.netguid_),
          reinterpret_cast<char*>(&other->_impl_.netguid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UnrealObjectRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[2]);
}

// ===================================================================

class ActorComponentRef::_Internal {
 public:
  using HasBits = decltype(std::declval<ActorComponentRef>()._impl_._has_bits_);
  static const ::unrealpb::UnrealObjectRef& owner(const ActorComponentRef* msg);
  static void set_has_owner(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_compname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::unrealpb::UnrealObjectRef&
ActorComponentRef::_Internal::owner(const ActorComponentRef* msg) {
  return *msg->_impl_.owner_;
}
ActorComponentRef::ActorComponentRef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.ActorComponentRef)
}
ActorComponentRef::ActorComponentRef(const ActorComponentRef& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActorComponentRef* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.compname_){}
    , decltype(_impl_.owner_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.compname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.compname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_compname()) {
    _this->_impl_.compname_.Set(from._internal_compname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_owner()) {
    _this->_impl_.owner_ = new ::unrealpb::UnrealObjectRef(*from._impl_.owner_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.ActorComponentRef)
}

inline void ActorComponentRef::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.compname_){}
    , decltype(_impl_.owner_){nullptr}
  };
  _impl_.compname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.compname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ActorComponentRef::~ActorComponentRef() {
  // @@protoc_insertion_point(destructor:unrealpb.ActorComponentRef)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActorComponentRef::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.compname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.owner_;
}

void ActorComponentRef::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActorComponentRef::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.ActorComponentRef)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.compname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.owner_ != nullptr);
      _impl_.owner_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActorComponentRef::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .unrealpb.UnrealObjectRef owner = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string compName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_compname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.ActorComponentRef.compName"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActorComponentRef::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.ActorComponentRef)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .unrealpb.UnrealObjectRef owner = 1;
  if (_internal_has_owner()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::owner(this),
        _Internal::owner(this).GetCachedSize(), target, stream);
  }

  // optional string compName = 2;
  if (_internal_has_compname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_compname().data(), static_cast<int>(this->_internal_compname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.ActorComponentRef.compName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_compname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.ActorComponentRef)
  return target;
}

size_t ActorComponentRef::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.ActorComponentRef)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string compName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_compname());
    }

    // optional .unrealpb.UnrealObjectRef owner = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActorComponentRef::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActorComponentRef::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActorComponentRef::GetClassData() const { return &_class_data_; }


void ActorComponentRef::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActorComponentRef*>(&to_msg);
  auto& from = static_cast<const ActorComponentRef&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.ActorComponentRef)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_compname(from._internal_compname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_owner()->::unrealpb::UnrealObjectRef::MergeFrom(
          from._internal_owner());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActorComponentRef::CopyFrom(const ActorComponentRef& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.ActorComponentRef)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorComponentRef::IsInitialized() const {
  return true;
}

void ActorComponentRef::InternalSwap(ActorComponentRef* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.compname_, lhs_arena,
      &other->_impl_.compname_, rhs_arena
  );
  swap(_impl_.owner_, other->_impl_.owner_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ActorComponentRef::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[3]);
}

// ===================================================================

class RemoteFunctionMessage::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& targetobj(const RemoteFunctionMessage* msg);
};

const ::unrealpb::UnrealObjectRef&
RemoteFunctionMessage::_Internal::targetobj(const RemoteFunctionMessage* msg) {
  return *msg->_impl_.targetobj_;
}
RemoteFunctionMessage::RemoteFunctionMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.RemoteFunctionMessage)
}
RemoteFunctionMessage::RemoteFunctionMessage(const RemoteFunctionMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RemoteFunctionMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.functionname_){}
    , decltype(_impl_.paramspayload_){}
    , decltype(_impl_.targetobj_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.functionname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.functionname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_functionname().empty()) {
    _this->_impl_.functionname_.Set(from._internal_functionname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.paramspayload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.paramspayload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_paramspayload().empty()) {
    _this->_impl_.paramspayload_.Set(from._internal_paramspayload(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_targetobj()) {
    _this->_impl_.targetobj_ = new ::unrealpb::UnrealObjectRef(*from._impl_.targetobj_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.RemoteFunctionMessage)
}

inline void RemoteFunctionMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.functionname_){}
    , decltype(_impl_.paramspayload_){}
    , decltype(_impl_.targetobj_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.functionname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.functionname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.paramspayload_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.paramspayload_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RemoteFunctionMessage::~RemoteFunctionMessage() {
  // @@protoc_insertion_point(destructor:unrealpb.RemoteFunctionMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RemoteFunctionMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.functionname_.Destroy();
  _impl_.paramspayload_.Destroy();
  if (this != internal_default_instance()) delete _impl_.targetobj_;
}

void RemoteFunctionMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RemoteFunctionMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.RemoteFunctionMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.functionname_.ClearToEmpty();
  _impl_.paramspayload_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.targetobj_ != nullptr) {
    delete _impl_.targetobj_;
  }
  _impl_.targetobj_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RemoteFunctionMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef targetObj = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_targetobj(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string functionName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_functionname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.RemoteFunctionMessage.functionName"));
        } else
          goto handle_unusual;
        continue;
      // bytes paramsPayload = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_paramspayload();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RemoteFunctionMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.RemoteFunctionMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef targetObj = 1;
  if (this->_internal_has_targetobj()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::targetobj(this),
        _Internal::targetobj(this).GetCachedSize(), target, stream);
  }

  // string functionName = 2;
  if (!this->_internal_functionname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_functionname().data(), static_cast<int>(this->_internal_functionname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.RemoteFunctionMessage.functionName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_functionname(), target);
  }

  // bytes paramsPayload = 3;
  if (!this->_internal_paramspayload().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_paramspayload(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.RemoteFunctionMessage)
  return target;
}

size_t RemoteFunctionMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.RemoteFunctionMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string functionName = 2;
  if (!this->_internal_functionname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_functionname());
  }

  // bytes paramsPayload = 3;
  if (!this->_internal_paramspayload().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_paramspayload());
  }

  // .unrealpb.UnrealObjectRef targetObj = 1;
  if (this->_internal_has_targetobj()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.targetobj_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RemoteFunctionMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RemoteFunctionMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RemoteFunctionMessage::GetClassData() const { return &_class_data_; }


void RemoteFunctionMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RemoteFunctionMessage*>(&to_msg);
  auto& from = static_cast<const RemoteFunctionMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.RemoteFunctionMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_functionname().empty()) {
    _this->_internal_set_functionname(from._internal_functionname());
  }
  if (!from._internal_paramspayload().empty()) {
    _this->_internal_set_paramspayload(from._internal_paramspayload());
  }
  if (from._internal_has_targetobj()) {
    _this->_internal_mutable_targetobj()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_targetobj());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RemoteFunctionMessage::CopyFrom(const RemoteFunctionMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.RemoteFunctionMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteFunctionMessage::IsInitialized() const {
  return true;
}

void RemoteFunctionMessage::InternalSwap(RemoteFunctionMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.functionname_, lhs_arena,
      &other->_impl_.functionname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.paramspayload_, lhs_arena,
      &other->_impl_.paramspayload_, rhs_arena
  );
  swap(_impl_.targetobj_, other->_impl_.targetobj_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoteFunctionMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[4]);
}

// ===================================================================

class SpawnObjectMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<SpawnObjectMessage>()._impl_._has_bits_);
  static const ::unrealpb::UnrealObjectRef& obj(const SpawnObjectMessage* msg);
  static void set_has_channelid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_localrole(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::unrealpb::FVector& location(const SpawnObjectMessage* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::unrealpb::UnrealObjectRef&
SpawnObjectMessage::_Internal::obj(const SpawnObjectMessage* msg) {
  return *msg->_impl_.obj_;
}
const ::unrealpb::FVector&
SpawnObjectMessage::_Internal::location(const SpawnObjectMessage* msg) {
  return *msg->_impl_.location_;
}
SpawnObjectMessage::SpawnObjectMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.SpawnObjectMessage)
}
SpawnObjectMessage::SpawnObjectMessage(const SpawnObjectMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpawnObjectMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obj_){nullptr}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.channelid_){}
    , decltype(_impl_.localrole_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_obj()) {
    _this->_impl_.obj_ = new ::unrealpb::UnrealObjectRef(*from._impl_.obj_);
  }
  if (from._internal_has_location()) {
    _this->_impl_.location_ = new ::unrealpb::FVector(*from._impl_.location_);
  }
  ::memcpy(&_impl_.channelid_, &from._impl_.channelid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.localrole_) -
    reinterpret_cast<char*>(&_impl_.channelid_)) + sizeof(_impl_.localrole_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.SpawnObjectMessage)
}

inline void SpawnObjectMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obj_){nullptr}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.channelid_){0u}
    , decltype(_impl_.localrole_){0u}
  };
}

SpawnObjectMessage::~SpawnObjectMessage() {
  // @@protoc_insertion_point(destructor:unrealpb.SpawnObjectMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpawnObjectMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.obj_;
  if (this != internal_default_instance()) delete _impl_.location_;
}

void SpawnObjectMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpawnObjectMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.SpawnObjectMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.obj_ != nullptr) {
    delete _impl_.obj_;
  }
  _impl_.obj_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.location_ != nullptr);
    _impl_.location_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.channelid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.localrole_) -
        reinterpret_cast<char*>(&_impl_.channelid_)) + sizeof(_impl_.localrole_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpawnObjectMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef obj = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_obj(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 channelId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_channelid(&has_bits);
          _impl_.channelid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 localRole = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_localrole(&has_bits);
          _impl_.localrole_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpawnObjectMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.SpawnObjectMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef obj = 1;
  if (this->_internal_has_obj()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::obj(this),
        _Internal::obj(this).GetCachedSize(), target, stream);
  }

  // optional uint32 channelId = 2;
  if (_internal_has_channelid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_channelid(), target);
  }

  // optional uint32 localRole = 3;
  if (_internal_has_localrole()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_localrole(), target);
  }

  // optional .unrealpb.FVector location = 5;
  if (_internal_has_location()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.SpawnObjectMessage)
  return target;
}

size_t SpawnObjectMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.SpawnObjectMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef obj = 1;
  if (this->_internal_has_obj()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.obj_);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .unrealpb.FVector location = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.location_);
    }

    // optional uint32 channelId = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_channelid());
    }

    // optional uint32 localRole = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_localrole());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpawnObjectMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpawnObjectMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpawnObjectMessage::GetClassData() const { return &_class_data_; }


void SpawnObjectMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpawnObjectMessage*>(&to_msg);
  auto& from = static_cast<const SpawnObjectMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.SpawnObjectMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_obj()) {
    _this->_internal_mutable_obj()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_obj());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_location()->::unrealpb::FVector::MergeFrom(
          from._internal_location());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.channelid_ = from._impl_.channelid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.localrole_ = from._impl_.localrole_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpawnObjectMessage::CopyFrom(const SpawnObjectMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.SpawnObjectMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpawnObjectMessage::IsInitialized() const {
  return true;
}

void SpawnObjectMessage::InternalSwap(SpawnObjectMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpawnObjectMessage, _impl_.localrole_)
      + sizeof(SpawnObjectMessage::_impl_.localrole_)
      - PROTOBUF_FIELD_OFFSET(SpawnObjectMessage, _impl_.obj_)>(
          reinterpret_cast<char*>(&_impl_.obj_),
          reinterpret_cast<char*>(&other->_impl_.obj_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpawnObjectMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[5]);
}

// ===================================================================

class DestroyObjectMessage::_Internal {
 public:
};

DestroyObjectMessage::DestroyObjectMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.DestroyObjectMessage)
}
DestroyObjectMessage::DestroyObjectMessage(const DestroyObjectMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DestroyObjectMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.netid_){}
    , decltype(_impl_.reason_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.netid_, &from._impl_.netid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.reason_) -
    reinterpret_cast<char*>(&_impl_.netid_)) + sizeof(_impl_.reason_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.DestroyObjectMessage)
}

inline void DestroyObjectMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.netid_){0u}
    , decltype(_impl_.reason_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DestroyObjectMessage::~DestroyObjectMessage() {
  // @@protoc_insertion_point(destructor:unrealpb.DestroyObjectMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DestroyObjectMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DestroyObjectMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DestroyObjectMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.DestroyObjectMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.netid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.reason_) -
      reinterpret_cast<char*>(&_impl_.netid_)) + sizeof(_impl_.reason_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DestroyObjectMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 netId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.netid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 reason = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DestroyObjectMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.DestroyObjectMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 netId = 1;
  if (this->_internal_netid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_netid(), target);
  }

  // uint32 reason = 2;
  if (this->_internal_reason() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.DestroyObjectMessage)
  return target;
}

size_t DestroyObjectMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.DestroyObjectMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 netId = 1;
  if (this->_internal_netid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_netid());
  }

  // uint32 reason = 2;
  if (this->_internal_reason() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reason());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DestroyObjectMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DestroyObjectMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DestroyObjectMessage::GetClassData() const { return &_class_data_; }


void DestroyObjectMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DestroyObjectMessage*>(&to_msg);
  auto& from = static_cast<const DestroyObjectMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.DestroyObjectMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_netid() != 0) {
    _this->_internal_set_netid(from._internal_netid());
  }
  if (from._internal_reason() != 0) {
    _this->_internal_set_reason(from._internal_reason());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DestroyObjectMessage::CopyFrom(const DestroyObjectMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.DestroyObjectMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DestroyObjectMessage::IsInitialized() const {
  return true;
}

void DestroyObjectMessage::InternalSwap(DestroyObjectMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DestroyObjectMessage, _impl_.reason_)
      + sizeof(DestroyObjectMessage::_impl_.reason_)
      - PROTOBUF_FIELD_OFFSET(DestroyObjectMessage, _impl_.netid_)>(
          reinterpret_cast<char*>(&_impl_.netid_),
          reinterpret_cast<char*>(&other->_impl_.netid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DestroyObjectMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[6]);
}

// ===================================================================

class HandoverContext::_Internal {
 public:
  using HasBits = decltype(std::declval<HandoverContext>()._impl_._has_bits_);
  static const ::unrealpb::UnrealObjectRef& obj(const HandoverContext* msg);
  static void set_has_clientconnid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::unrealpb::UnrealObjectRef&
HandoverContext::_Internal::obj(const HandoverContext* msg) {
  return *msg->_impl_.obj_;
}
HandoverContext::HandoverContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.HandoverContext)
}
HandoverContext::HandoverContext(const HandoverContext& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HandoverContext* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obj_){nullptr}
    , decltype(_impl_.clientconnid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_obj()) {
    _this->_impl_.obj_ = new ::unrealpb::UnrealObjectRef(*from._impl_.obj_);
  }
  _this->_impl_.clientconnid_ = from._impl_.clientconnid_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.HandoverContext)
}

inline void HandoverContext::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.obj_){nullptr}
    , decltype(_impl_.clientconnid_){0u}
  };
}

HandoverContext::~HandoverContext() {
  // @@protoc_insertion_point(destructor:unrealpb.HandoverContext)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HandoverContext::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.obj_;
}

void HandoverContext::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HandoverContext::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.HandoverContext)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.obj_ != nullptr) {
    delete _impl_.obj_;
  }
  _impl_.obj_ = nullptr;
  _impl_.clientconnid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HandoverContext::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef obj = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_obj(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 clientConnId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_clientconnid(&has_bits);
          _impl_.clientconnid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HandoverContext::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.HandoverContext)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef obj = 1;
  if (this->_internal_has_obj()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::obj(this),
        _Internal::obj(this).GetCachedSize(), target, stream);
  }

  // optional uint32 clientConnId = 2;
  if (_internal_has_clientconnid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_clientconnid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.HandoverContext)
  return target;
}

size_t HandoverContext::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.HandoverContext)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef obj = 1;
  if (this->_internal_has_obj()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.obj_);
  }

  // optional uint32 clientConnId = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_clientconnid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HandoverContext::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HandoverContext::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HandoverContext::GetClassData() const { return &_class_data_; }


void HandoverContext::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HandoverContext*>(&to_msg);
  auto& from = static_cast<const HandoverContext&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.HandoverContext)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_obj()) {
    _this->_internal_mutable_obj()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_obj());
  }
  if (from._internal_has_clientconnid()) {
    _this->_internal_set_clientconnid(from._internal_clientconnid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HandoverContext::CopyFrom(const HandoverContext& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.HandoverContext)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HandoverContext::IsInitialized() const {
  return true;
}

void HandoverContext::InternalSwap(HandoverContext* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HandoverContext, _impl_.clientconnid_)
      + sizeof(HandoverContext::_impl_.clientconnid_)
      - PROTOBUF_FIELD_OFFSET(HandoverContext, _impl_.obj_)>(
          reinterpret_cast<char*>(&_impl_.obj_),
          reinterpret_cast<char*>(&other->_impl_.obj_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HandoverContext::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[7]);
}

// ===================================================================

class GetHandoverContextMessage::_Internal {
 public:
};

GetHandoverContextMessage::GetHandoverContextMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.GetHandoverContextMessage)
}
GetHandoverContextMessage::GetHandoverContextMessage(const GetHandoverContextMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetHandoverContextMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.netid_){}
    , decltype(_impl_.srcchannelid_){}
    , decltype(_impl_.dstchannelid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.netid_, &from._impl_.netid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dstchannelid_) -
    reinterpret_cast<char*>(&_impl_.netid_)) + sizeof(_impl_.dstchannelid_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.GetHandoverContextMessage)
}

inline void GetHandoverContextMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.netid_){0u}
    , decltype(_impl_.srcchannelid_){0u}
    , decltype(_impl_.dstchannelid_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetHandoverContextMessage::~GetHandoverContextMessage() {
  // @@protoc_insertion_point(destructor:unrealpb.GetHandoverContextMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetHandoverContextMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetHandoverContextMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetHandoverContextMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.GetHandoverContextMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.netid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.dstchannelid_) -
      reinterpret_cast<char*>(&_impl_.netid_)) + sizeof(_impl_.dstchannelid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetHandoverContextMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 netId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.netid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 srcChannelId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.srcchannelid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 dstChannelId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.dstchannelid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetHandoverContextMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.GetHandoverContextMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 netId = 1;
  if (this->_internal_netid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_netid(), target);
  }

  // uint32 srcChannelId = 2;
  if (this->_internal_srcchannelid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_srcchannelid(), target);
  }

  // uint32 dstChannelId = 3;
  if (this->_internal_dstchannelid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_dstchannelid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.GetHandoverContextMessage)
  return target;
}

size_t GetHandoverContextMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.GetHandoverContextMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 netId = 1;
  if (this->_internal_netid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_netid());
  }

  // uint32 srcChannelId = 2;
  if (this->_internal_srcchannelid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_srcchannelid());
  }

  // uint32 dstChannelId = 3;
  if (this->_internal_dstchannelid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dstchannelid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetHandoverContextMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetHandoverContextMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetHandoverContextMessage::GetClassData() const { return &_class_data_; }


void GetHandoverContextMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetHandoverContextMessage*>(&to_msg);
  auto& from = static_cast<const GetHandoverContextMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.GetHandoverContextMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_netid() != 0) {
    _this->_internal_set_netid(from._internal_netid());
  }
  if (from._internal_srcchannelid() != 0) {
    _this->_internal_set_srcchannelid(from._internal_srcchannelid());
  }
  if (from._internal_dstchannelid() != 0) {
    _this->_internal_set_dstchannelid(from._internal_dstchannelid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetHandoverContextMessage::CopyFrom(const GetHandoverContextMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.GetHandoverContextMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetHandoverContextMessage::IsInitialized() const {
  return true;
}

void GetHandoverContextMessage::InternalSwap(GetHandoverContextMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetHandoverContextMessage, _impl_.dstchannelid_)
      + sizeof(GetHandoverContextMessage::_impl_.dstchannelid_)
      - PROTOBUF_FIELD_OFFSET(GetHandoverContextMessage, _impl_.netid_)>(
          reinterpret_cast<char*>(&_impl_.netid_),
          reinterpret_cast<char*>(&other->_impl_.netid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetHandoverContextMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[8]);
}

// ===================================================================

class GetHandoverContextResultMessage::_Internal {
 public:
};

GetHandoverContextResultMessage::GetHandoverContextResultMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.GetHandoverContextResultMessage)
}
GetHandoverContextResultMessage::GetHandoverContextResultMessage(const GetHandoverContextResultMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetHandoverContextResultMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.context_){from._impl_.context_}
    , decltype(_impl_.netid_){}
    , decltype(_impl_.srcchannelid_){}
    , decltype(_impl_.dstchannelid_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.netid_, &from._impl_.netid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dstchannelid_) -
    reinterpret_cast<char*>(&_impl_.netid_)) + sizeof(_impl_.dstchannelid_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.GetHandoverContextResultMessage)
}

inline void GetHandoverContextResultMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.context_){arena}
    , decltype(_impl_.netid_){0u}
    , decltype(_impl_.srcchannelid_){0u}
    , decltype(_impl_.dstchannelid_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetHandoverContextResultMessage::~GetHandoverContextResultMessage() {
  // @@protoc_insertion_point(destructor:unrealpb.GetHandoverContextResultMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetHandoverContextResultMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.context_.~RepeatedPtrField();
}

void GetHandoverContextResultMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetHandoverContextResultMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.GetHandoverContextResultMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.context_.Clear();
  ::memset(&_impl_.netid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.dstchannelid_) -
      reinterpret_cast<char*>(&_impl_.netid_)) + sizeof(_impl_.dstchannelid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetHandoverContextResultMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 netId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.netid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 srcChannelId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.srcchannelid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 dstChannelId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.dstchannelid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .unrealpb.HandoverContext context = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_context(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetHandoverContextResultMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.GetHandoverContextResultMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 netId = 1;
  if (this->_internal_netid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_netid(), target);
  }

  // uint32 srcChannelId = 2;
  if (this->_internal_srcchannelid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_srcchannelid(), target);
  }

  // uint32 dstChannelId = 3;
  if (this->_internal_dstchannelid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_dstchannelid(), target);
  }

  // repeated .unrealpb.HandoverContext context = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_context_size()); i < n; i++) {
    const auto& repfield = this->_internal_context(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.GetHandoverContextResultMessage)
  return target;
}

size_t GetHandoverContextResultMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.GetHandoverContextResultMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unrealpb.HandoverContext context = 4;
  total_size += 1UL * this->_internal_context_size();
  for (const auto& msg : this->_impl_.context_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 netId = 1;
  if (this->_internal_netid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_netid());
  }

  // uint32 srcChannelId = 2;
  if (this->_internal_srcchannelid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_srcchannelid());
  }

  // uint32 dstChannelId = 3;
  if (this->_internal_dstchannelid() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dstchannelid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetHandoverContextResultMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetHandoverContextResultMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetHandoverContextResultMessage::GetClassData() const { return &_class_data_; }


void GetHandoverContextResultMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetHandoverContextResultMessage*>(&to_msg);
  auto& from = static_cast<const GetHandoverContextResultMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.GetHandoverContextResultMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.context_.MergeFrom(from._impl_.context_);
  if (from._internal_netid() != 0) {
    _this->_internal_set_netid(from._internal_netid());
  }
  if (from._internal_srcchannelid() != 0) {
    _this->_internal_set_srcchannelid(from._internal_srcchannelid());
  }
  if (from._internal_dstchannelid() != 0) {
    _this->_internal_set_dstchannelid(from._internal_dstchannelid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetHandoverContextResultMessage::CopyFrom(const GetHandoverContextResultMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.GetHandoverContextResultMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetHandoverContextResultMessage::IsInitialized() const {
  return true;
}

void GetHandoverContextResultMessage::InternalSwap(GetHandoverContextResultMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.context_.InternalSwap(&other->_impl_.context_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetHandoverContextResultMessage, _impl_.dstchannelid_)
      + sizeof(GetHandoverContextResultMessage::_impl_.dstchannelid_)
      - PROTOBUF_FIELD_OFFSET(GetHandoverContextResultMessage, _impl_.netid_)>(
          reinterpret_cast<char*>(&_impl_.netid_),
          reinterpret_cast<char*>(&other->_impl_.netid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetHandoverContextResultMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[9]);
}

// ===================================================================

class HandoverData::_Internal {
 public:
  using HasBits = decltype(std::declval<HandoverData>()._impl_._has_bits_);
  static const ::PROTOBUF_NAMESPACE_ID::Any& channeldata(const HandoverData* msg);
  static void set_has_channeldata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::PROTOBUF_NAMESPACE_ID::Any&
HandoverData::_Internal::channeldata(const HandoverData* msg) {
  return *msg->_impl_.channeldata_;
}
void HandoverData::clear_channeldata() {
  if (_impl_.channeldata_ != nullptr) _impl_.channeldata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
HandoverData::HandoverData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.HandoverData)
}
HandoverData::HandoverData(const HandoverData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HandoverData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.context_){from._impl_.context_}
    , decltype(_impl_.channeldata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_channeldata()) {
    _this->_impl_.channeldata_ = new ::PROTOBUF_NAMESPACE_ID::Any(*from._impl_.channeldata_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.HandoverData)
}

inline void HandoverData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.context_){arena}
    , decltype(_impl_.channeldata_){nullptr}
  };
}

HandoverData::~HandoverData() {
  // @@protoc_insertion_point(destructor:unrealpb.HandoverData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HandoverData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.context_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.channeldata_;
}

void HandoverData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HandoverData::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.HandoverData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.context_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.channeldata_ != nullptr);
    _impl_.channeldata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HandoverData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .unrealpb.HandoverContext context = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_context(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Any channelData = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_channeldata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HandoverData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.HandoverData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .unrealpb.HandoverContext context = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_context_size()); i < n; i++) {
    const auto& repfield = this->_internal_context(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .google.protobuf.Any channelData = 2;
  if (_internal_has_channeldata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::channeldata(this),
        _Internal::channeldata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.HandoverData)
  return target;
}

size_t HandoverData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.HandoverData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unrealpb.HandoverContext context = 1;
  total_size += 1UL * this->_internal_context_size();
  for (const auto& msg : this->_impl_.context_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .google.protobuf.Any channelData = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.channeldata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HandoverData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HandoverData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HandoverData::GetClassData() const { return &_class_data_; }


void HandoverData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HandoverData*>(&to_msg);
  auto& from = static_cast<const HandoverData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.HandoverData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.context_.MergeFrom(from._impl_.context_);
  if (from._internal_has_channeldata()) {
    _this->_internal_mutable_channeldata()->::PROTOBUF_NAMESPACE_ID::Any::MergeFrom(
        from._internal_channeldata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HandoverData::CopyFrom(const HandoverData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.HandoverData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HandoverData::IsInitialized() const {
  return true;
}

void HandoverData::InternalSwap(HandoverData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.context_.InternalSwap(&other->_impl_.context_);
  swap(_impl_.channeldata_, other->_impl_.channeldata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HandoverData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[10]);
}

// ===================================================================

class GetUnrealObjectRefMessage::_Internal {
 public:
};

GetUnrealObjectRefMessage::GetUnrealObjectRefMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.GetUnrealObjectRefMessage)
}
GetUnrealObjectRefMessage::GetUnrealObjectRefMessage(const GetUnrealObjectRefMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetUnrealObjectRefMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.netguid_){from._impl_.netguid_}
    , /*decltype(_impl_._netguid_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:unrealpb.GetUnrealObjectRefMessage)
}

inline void GetUnrealObjectRefMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.netguid_){arena}
    , /*decltype(_impl_._netguid_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetUnrealObjectRefMessage::~GetUnrealObjectRefMessage() {
  // @@protoc_insertion_point(destructor:unrealpb.GetUnrealObjectRefMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetUnrealObjectRefMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.netguid_.~RepeatedField();
}

void GetUnrealObjectRefMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetUnrealObjectRefMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.GetUnrealObjectRefMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.netguid_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetUnrealObjectRefMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 netGUID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_netguid(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_netguid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetUnrealObjectRefMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.GetUnrealObjectRefMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 netGUID = 1;
  {
    int byte_size = _impl_._netguid_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          1, _internal_netguid(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.GetUnrealObjectRefMessage)
  return target;
}

size_t GetUnrealObjectRefMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.GetUnrealObjectRefMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 netGUID = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.netguid_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._netguid_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetUnrealObjectRefMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetUnrealObjectRefMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetUnrealObjectRefMessage::GetClassData() const { return &_class_data_; }


void GetUnrealObjectRefMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetUnrealObjectRefMessage*>(&to_msg);
  auto& from = static_cast<const GetUnrealObjectRefMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.GetUnrealObjectRefMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.netguid_.MergeFrom(from._impl_.netguid_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetUnrealObjectRefMessage::CopyFrom(const GetUnrealObjectRefMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.GetUnrealObjectRefMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUnrealObjectRefMessage::IsInitialized() const {
  return true;
}

void GetUnrealObjectRefMessage::InternalSwap(GetUnrealObjectRefMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.netguid_.InternalSwap(&other->_impl_.netguid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetUnrealObjectRefMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[11]);
}

// ===================================================================

class GetUnrealObjectRefResultMessage::_Internal {
 public:
};

GetUnrealObjectRefResultMessage::GetUnrealObjectRefResultMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.GetUnrealObjectRefResultMessage)
}
GetUnrealObjectRefResultMessage::GetUnrealObjectRefResultMessage(const GetUnrealObjectRefResultMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetUnrealObjectRefResultMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.objref_){from._impl_.objref_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:unrealpb.GetUnrealObjectRefResultMessage)
}

inline void GetUnrealObjectRefResultMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.objref_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetUnrealObjectRefResultMessage::~GetUnrealObjectRefResultMessage() {
  // @@protoc_insertion_point(destructor:unrealpb.GetUnrealObjectRefResultMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetUnrealObjectRefResultMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.objref_.~RepeatedPtrField();
}

void GetUnrealObjectRefResultMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetUnrealObjectRefResultMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.GetUnrealObjectRefResultMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.objref_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetUnrealObjectRefResultMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .unrealpb.UnrealObjectRef objRef = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objref(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetUnrealObjectRefResultMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.GetUnrealObjectRefResultMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .unrealpb.UnrealObjectRef objRef = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_objref_size()); i < n; i++) {
    const auto& repfield = this->_internal_objref(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.GetUnrealObjectRefResultMessage)
  return target;
}

size_t GetUnrealObjectRefResultMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.GetUnrealObjectRefResultMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unrealpb.UnrealObjectRef objRef = 1;
  total_size += 1UL * this->_internal_objref_size();
  for (const auto& msg : this->_impl_.objref_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetUnrealObjectRefResultMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetUnrealObjectRefResultMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetUnrealObjectRefResultMessage::GetClassData() const { return &_class_data_; }


void GetUnrealObjectRefResultMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetUnrealObjectRefResultMessage*>(&to_msg);
  auto& from = static_cast<const GetUnrealObjectRefResultMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.GetUnrealObjectRefResultMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.objref_.MergeFrom(from._impl_.objref_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetUnrealObjectRefResultMessage::CopyFrom(const GetUnrealObjectRefResultMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.GetUnrealObjectRefResultMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUnrealObjectRefResultMessage::IsInitialized() const {
  return true;
}

void GetUnrealObjectRefResultMessage::InternalSwap(GetUnrealObjectRefResultMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.objref_.InternalSwap(&other->_impl_.objref_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetUnrealObjectRefResultMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[12]);
}

// ===================================================================

class SpatialEntityState::_Internal {
 public:
  using HasBits = decltype(std::declval<SpatialEntityState>()._impl_._has_bits_);
  static const ::unrealpb::UnrealObjectRef& objref(const SpatialEntityState* msg);
  static const ::PROTOBUF_NAMESPACE_ID::Any& entitydata(const SpatialEntityState* msg);
  static void set_has_entitydata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::unrealpb::UnrealObjectRef&
SpatialEntityState::_Internal::objref(const SpatialEntityState* msg) {
  return *msg->_impl_.objref_;
}
const ::PROTOBUF_NAMESPACE_ID::Any&
SpatialEntityState::_Internal::entitydata(const SpatialEntityState* msg) {
  return *msg->_impl_.entitydata_;
}
void SpatialEntityState::clear_entitydata() {
  if (_impl_.entitydata_ != nullptr) _impl_.entitydata_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
SpatialEntityState::SpatialEntityState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.SpatialEntityState)
}
SpatialEntityState::SpatialEntityState(const SpatialEntityState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpatialEntityState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objref_){nullptr}
    , decltype(_impl_.entitydata_){nullptr}
    , decltype(_impl_.removed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_objref()) {
    _this->_impl_.objref_ = new ::unrealpb::UnrealObjectRef(*from._impl_.objref_);
  }
  if (from._internal_has_entitydata()) {
    _this->_impl_.entitydata_ = new ::PROTOBUF_NAMESPACE_ID::Any(*from._impl_.entitydata_);
  }
  _this->_impl_.removed_ = from._impl_.removed_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.SpatialEntityState)
}

inline void SpatialEntityState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.objref_){nullptr}
    , decltype(_impl_.entitydata_){nullptr}
    , decltype(_impl_.removed_){false}
  };
}

SpatialEntityState::~SpatialEntityState() {
  // @@protoc_insertion_point(destructor:unrealpb.SpatialEntityState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SpatialEntityState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.objref_;
  if (this != internal_default_instance()) delete _impl_.entitydata_;
}

void SpatialEntityState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpatialEntityState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.SpatialEntityState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.objref_ != nullptr) {
    delete _impl_.objref_;
  }
  _impl_.objref_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.entitydata_ != nullptr);
    _impl_.entitydata_->Clear();
  }
  _impl_.removed_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpatialEntityState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef objRef = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_objref(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool removed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .google.protobuf.Any entityData = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_entitydata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpatialEntityState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.SpatialEntityState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef objRef = 1;
  if (this->_internal_has_objref()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::objref(this),
        _Internal::objref(this).GetCachedSize(), target, stream);
  }

  // bool removed = 2;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_removed(), target);
  }

  // optional .google.protobuf.Any entityData = 3;
  if (_internal_has_entitydata()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::entitydata(this),
        _Internal::entitydata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.SpatialEntityState)
  return target;
}

size_t SpatialEntityState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.SpatialEntityState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef objRef = 1;
  if (this->_internal_has_objref()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.objref_);
  }

  // optional .google.protobuf.Any entityData = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.entitydata_);
  }

  // bool removed = 2;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpatialEntityState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpatialEntityState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpatialEntityState::GetClassData() const { return &_class_data_; }


void SpatialEntityState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpatialEntityState*>(&to_msg);
  auto& from = static_cast<const SpatialEntityState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.SpatialEntityState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_objref()) {
    _this->_internal_mutable_objref()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_objref());
  }
  if (from._internal_has_entitydata()) {
    _this->_internal_mutable_entitydata()->::PROTOBUF_NAMESPACE_ID::Any::MergeFrom(
        from._internal_entitydata());
  }
  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpatialEntityState::CopyFrom(const SpatialEntityState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.SpatialEntityState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpatialEntityState::IsInitialized() const {
  return true;
}

void SpatialEntityState::InternalSwap(SpatialEntityState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpatialEntityState, _impl_.removed_)
      + sizeof(SpatialEntityState::_impl_.removed_)
      - PROTOBUF_FIELD_OFFSET(SpatialEntityState, _impl_.objref_)>(
          reinterpret_cast<char*>(&_impl_.objref_),
          reinterpret_cast<char*>(&other->_impl_.objref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpatialEntityState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[13]);
}

// ===================================================================

SpatialChannelData_EntitiesEntry_DoNotUse::SpatialChannelData_EntitiesEntry_DoNotUse() {}
SpatialChannelData_EntitiesEntry_DoNotUse::SpatialChannelData_EntitiesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void SpatialChannelData_EntitiesEntry_DoNotUse::MergeFrom(const SpatialChannelData_EntitiesEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata SpatialChannelData_EntitiesEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[14]);
}

// ===================================================================

class SpatialChannelData::_Internal {
 public:
};

SpatialChannelData::SpatialChannelData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &SpatialChannelData::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:unrealpb.SpatialChannelData)
}
SpatialChannelData::SpatialChannelData(const SpatialChannelData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SpatialChannelData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.entities_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.entities_.MergeFrom(from._impl_.entities_);
  // @@protoc_insertion_point(copy_constructor:unrealpb.SpatialChannelData)
}

inline void SpatialChannelData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.entities_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SpatialChannelData::~SpatialChannelData() {
  // @@protoc_insertion_point(destructor:unrealpb.SpatialChannelData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void SpatialChannelData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entities_.Destruct();
  _impl_.entities_.~MapField();
}

void SpatialChannelData::ArenaDtor(void* object) {
  SpatialChannelData* _this = reinterpret_cast< SpatialChannelData* >(object);
  _this->_impl_.entities_.Destruct();
}
void SpatialChannelData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SpatialChannelData::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.SpatialChannelData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.entities_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpatialChannelData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<uint32, .unrealpb.SpatialEntityState> entities = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.entities_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SpatialChannelData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.SpatialChannelData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<uint32, .unrealpb.SpatialEntityState> entities = 1;
  if (!this->_internal_entities().empty()) {
    using MapType = ::_pb::Map<uint32_t, ::unrealpb::SpatialEntityState>;
    using WireHelper = SpatialChannelData_EntitiesEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_entities();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.SpatialChannelData)
  return target;
}

size_t SpatialChannelData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.SpatialChannelData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<uint32, .unrealpb.SpatialEntityState> entities = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_entities_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< uint32_t, ::unrealpb::SpatialEntityState >::const_iterator
      it = this->_internal_entities().begin();
      it != this->_internal_entities().end(); ++it) {
    total_size += SpatialChannelData_EntitiesEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SpatialChannelData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SpatialChannelData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SpatialChannelData::GetClassData() const { return &_class_data_; }


void SpatialChannelData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SpatialChannelData*>(&to_msg);
  auto& from = static_cast<const SpatialChannelData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.SpatialChannelData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.entities_.MergeFrom(from._impl_.entities_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SpatialChannelData::CopyFrom(const SpatialChannelData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.SpatialChannelData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpatialChannelData::IsInitialized() const {
  return true;
}

void SpatialChannelData::InternalSwap(SpatialChannelData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.entities_.InternalSwap(&other->_impl_.entities_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpatialChannelData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[15]);
}

// ===================================================================

class FRepMovement::_Internal {
 public:
  using HasBits = decltype(std::declval<FRepMovement>()._impl_._has_bits_);
  static const ::unrealpb::FVector& linearvelocity(const FRepMovement* msg);
  static void set_has_linearvelocity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::unrealpb::FVector& angularvelocity(const FRepMovement* msg);
  static void set_has_angularvelocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::unrealpb::FVector& location(const FRepMovement* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::unrealpb::FVector& rotation(const FRepMovement* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bsimulatedphysicsleep(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_brepphysics(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::unrealpb::FVector&
FRepMovement::_Internal::linearvelocity(const FRepMovement* msg) {
  return *msg->_impl_.linearvelocity_;
}
const ::unrealpb::FVector&
FRepMovement::_Internal::angularvelocity(const FRepMovement* msg) {
  return *msg->_impl_.angularvelocity_;
}
const ::unrealpb::FVector&
FRepMovement::_Internal::location(const FRepMovement* msg) {
  return *msg->_impl_.location_;
}
const ::unrealpb::FVector&
FRepMovement::_Internal::rotation(const FRepMovement* msg) {
  return *msg->_impl_.rotation_;
}
FRepMovement::FRepMovement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.FRepMovement)
}
FRepMovement::FRepMovement(const FRepMovement& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FRepMovement* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.linearvelocity_){nullptr}
    , decltype(_impl_.angularvelocity_){nullptr}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.bsimulatedphysicsleep_){}
    , decltype(_impl_.brepphysics_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_linearvelocity()) {
    _this->_impl_.linearvelocity_ = new ::unrealpb::FVector(*from._impl_.linearvelocity_);
  }
  if (from._internal_has_angularvelocity()) {
    _this->_impl_.angularvelocity_ = new ::unrealpb::FVector(*from._impl_.angularvelocity_);
  }
  if (from._internal_has_location()) {
    _this->_impl_.location_ = new ::unrealpb::FVector(*from._impl_.location_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::unrealpb::FVector(*from._impl_.rotation_);
  }
  ::memcpy(&_impl_.bsimulatedphysicsleep_, &from._impl_.bsimulatedphysicsleep_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.brepphysics_) -
    reinterpret_cast<char*>(&_impl_.bsimulatedphysicsleep_)) + sizeof(_impl_.brepphysics_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.FRepMovement)
}

inline void FRepMovement::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.linearvelocity_){nullptr}
    , decltype(_impl_.angularvelocity_){nullptr}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.bsimulatedphysicsleep_){false}
    , decltype(_impl_.brepphysics_){false}
  };
}

FRepMovement::~FRepMovement() {
  // @@protoc_insertion_point(destructor:unrealpb.FRepMovement)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FRepMovement::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.linearvelocity_;
  if (this != internal_default_instance()) delete _impl_.angularvelocity_;
  if (this != internal_default_instance()) delete _impl_.location_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
}

void FRepMovement::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FRepMovement::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.FRepMovement)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.linearvelocity_ != nullptr);
      _impl_.linearvelocity_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.angularvelocity_ != nullptr);
      _impl_.angularvelocity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.location_ != nullptr);
      _impl_.location_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
  }
  ::memset(&_impl_.bsimulatedphysicsleep_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.brepphysics_) -
      reinterpret_cast<char*>(&_impl_.bsimulatedphysicsleep_)) + sizeof(_impl_.brepphysics_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FRepMovement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .unrealpb.FVector linearVelocity = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_linearvelocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector angularVelocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angularvelocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector rotation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bSimulatedPhysicSleep = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bsimulatedphysicsleep(&has_bits);
          _impl_.bsimulatedphysicsleep_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bRepPhysics = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_brepphysics(&has_bits);
          _impl_.brepphysics_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FRepMovement::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.FRepMovement)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .unrealpb.FVector linearVelocity = 1;
  if (_internal_has_linearvelocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::linearvelocity(this),
        _Internal::linearvelocity(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector angularVelocity = 2;
  if (_internal_has_angularvelocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angularvelocity(this),
        _Internal::angularvelocity(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector location = 3;
  if (_internal_has_location()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector rotation = 4;
  if (_internal_has_rotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // optional bool bSimulatedPhysicSleep = 5;
  if (_internal_has_bsimulatedphysicsleep()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_bsimulatedphysicsleep(), target);
  }

  // optional bool bRepPhysics = 6;
  if (_internal_has_brepphysics()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_brepphysics(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.FRepMovement)
  return target;
}

size_t FRepMovement::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.FRepMovement)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .unrealpb.FVector linearVelocity = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.linearvelocity_);
    }

    // optional .unrealpb.FVector angularVelocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.angularvelocity_);
    }

    // optional .unrealpb.FVector location = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.location_);
    }

    // optional .unrealpb.FVector rotation = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotation_);
    }

    // optional bool bSimulatedPhysicSleep = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool bRepPhysics = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FRepMovement::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FRepMovement::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FRepMovement::GetClassData() const { return &_class_data_; }


void FRepMovement::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FRepMovement*>(&to_msg);
  auto& from = static_cast<const FRepMovement&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.FRepMovement)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_linearvelocity()->::unrealpb::FVector::MergeFrom(
          from._internal_linearvelocity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_angularvelocity()->::unrealpb::FVector::MergeFrom(
          from._internal_angularvelocity());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_location()->::unrealpb::FVector::MergeFrom(
          from._internal_location());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_rotation()->::unrealpb::FVector::MergeFrom(
          from._internal_rotation());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.bsimulatedphysicsleep_ = from._impl_.bsimulatedphysicsleep_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.brepphysics_ = from._impl_.brepphysics_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FRepMovement::CopyFrom(const FRepMovement& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.FRepMovement)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FRepMovement::IsInitialized() const {
  return true;
}

void FRepMovement::InternalSwap(FRepMovement* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FRepMovement, _impl_.brepphysics_)
      + sizeof(FRepMovement::_impl_.brepphysics_)
      - PROTOBUF_FIELD_OFFSET(FRepMovement, _impl_.linearvelocity_)>(
          reinterpret_cast<char*>(&_impl_.linearvelocity_),
          reinterpret_cast<char*>(&other->_impl_.linearvelocity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FRepMovement::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[16]);
}

// ===================================================================

class FRepAttachment::_Internal {
 public:
  using HasBits = decltype(std::declval<FRepAttachment>()._impl_._has_bits_);
  static const ::unrealpb::UnrealObjectRef& attachparent(const FRepAttachment* msg);
  static void set_has_attachparent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::unrealpb::FVector& locationoffset(const FRepAttachment* msg);
  static void set_has_locationoffset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::unrealpb::FVector& relativescale(const FRepAttachment* msg);
  static void set_has_relativescale(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::unrealpb::FVector& rotationoffset(const FRepAttachment* msg);
  static void set_has_rotationoffset(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_attachsocket(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::unrealpb::ActorComponentRef& attachcomponent(const FRepAttachment* msg);
  static void set_has_attachcomponent(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::unrealpb::UnrealObjectRef&
FRepAttachment::_Internal::attachparent(const FRepAttachment* msg) {
  return *msg->_impl_.attachparent_;
}
const ::unrealpb::FVector&
FRepAttachment::_Internal::locationoffset(const FRepAttachment* msg) {
  return *msg->_impl_.locationoffset_;
}
const ::unrealpb::FVector&
FRepAttachment::_Internal::relativescale(const FRepAttachment* msg) {
  return *msg->_impl_.relativescale_;
}
const ::unrealpb::FVector&
FRepAttachment::_Internal::rotationoffset(const FRepAttachment* msg) {
  return *msg->_impl_.rotationoffset_;
}
const ::unrealpb::ActorComponentRef&
FRepAttachment::_Internal::attachcomponent(const FRepAttachment* msg) {
  return *msg->_impl_.attachcomponent_;
}
FRepAttachment::FRepAttachment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.FRepAttachment)
}
FRepAttachment::FRepAttachment(const FRepAttachment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FRepAttachment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attachsocket_){}
    , decltype(_impl_.attachparent_){nullptr}
    , decltype(_impl_.locationoffset_){nullptr}
    , decltype(_impl_.relativescale_){nullptr}
    , decltype(_impl_.rotationoffset_){nullptr}
    , decltype(_impl_.attachcomponent_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.attachsocket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attachsocket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attachsocket()) {
    _this->_impl_.attachsocket_.Set(from._internal_attachsocket(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_attachparent()) {
    _this->_impl_.attachparent_ = new ::unrealpb::UnrealObjectRef(*from._impl_.attachparent_);
  }
  if (from._internal_has_locationoffset()) {
    _this->_impl_.locationoffset_ = new ::unrealpb::FVector(*from._impl_.locationoffset_);
  }
  if (from._internal_has_relativescale()) {
    _this->_impl_.relativescale_ = new ::unrealpb::FVector(*from._impl_.relativescale_);
  }
  if (from._internal_has_rotationoffset()) {
    _this->_impl_.rotationoffset_ = new ::unrealpb::FVector(*from._impl_.rotationoffset_);
  }
  if (from._internal_has_attachcomponent()) {
    _this->_impl_.attachcomponent_ = new ::unrealpb::ActorComponentRef(*from._impl_.attachcomponent_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.FRepAttachment)
}

inline void FRepAttachment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attachsocket_){}
    , decltype(_impl_.attachparent_){nullptr}
    , decltype(_impl_.locationoffset_){nullptr}
    , decltype(_impl_.relativescale_){nullptr}
    , decltype(_impl_.rotationoffset_){nullptr}
    , decltype(_impl_.attachcomponent_){nullptr}
  };
  _impl_.attachsocket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attachsocket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FRepAttachment::~FRepAttachment() {
  // @@protoc_insertion_point(destructor:unrealpb.FRepAttachment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FRepAttachment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attachsocket_.Destroy();
  if (this != internal_default_instance()) delete _impl_.attachparent_;
  if (this != internal_default_instance()) delete _impl_.locationoffset_;
  if (this != internal_default_instance()) delete _impl_.relativescale_;
  if (this != internal_default_instance()) delete _impl_.rotationoffset_;
  if (this != internal_default_instance()) delete _impl_.attachcomponent_;
}

void FRepAttachment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FRepAttachment::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.FRepAttachment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.attachsocket_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.attachparent_ != nullptr);
      _impl_.attachparent_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.locationoffset_ != nullptr);
      _impl_.locationoffset_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.relativescale_ != nullptr);
      _impl_.relativescale_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.rotationoffset_ != nullptr);
      _impl_.rotationoffset_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.attachcomponent_ != nullptr);
      _impl_.attachcomponent_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FRepAttachment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .unrealpb.UnrealObjectRef attachParent = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_attachparent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector locationOffset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_locationoffset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector relativeScale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_relativescale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector rotationOffset = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotationoffset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string attachSocket = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_attachsocket();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.FRepAttachment.attachSocket"));
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.ActorComponentRef attachComponent = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_attachcomponent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FRepAttachment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.FRepAttachment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .unrealpb.UnrealObjectRef attachParent = 1;
  if (_internal_has_attachparent()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::attachparent(this),
        _Internal::attachparent(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector locationOffset = 2;
  if (_internal_has_locationoffset()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::locationoffset(this),
        _Internal::locationoffset(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector relativeScale = 3;
  if (_internal_has_relativescale()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::relativescale(this),
        _Internal::relativescale(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector rotationOffset = 4;
  if (_internal_has_rotationoffset()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rotationoffset(this),
        _Internal::rotationoffset(this).GetCachedSize(), target, stream);
  }

  // optional string attachSocket = 5;
  if (_internal_has_attachsocket()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_attachsocket().data(), static_cast<int>(this->_internal_attachsocket().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.FRepAttachment.attachSocket");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_attachsocket(), target);
  }

  // optional .unrealpb.ActorComponentRef attachComponent = 6;
  if (_internal_has_attachcomponent()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::attachcomponent(this),
        _Internal::attachcomponent(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.FRepAttachment)
  return target;
}

size_t FRepAttachment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.FRepAttachment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string attachSocket = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_attachsocket());
    }

    // optional .unrealpb.UnrealObjectRef attachParent = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attachparent_);
    }

    // optional .unrealpb.FVector locationOffset = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.locationoffset_);
    }

    // optional .unrealpb.FVector relativeScale = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.relativescale_);
    }

    // optional .unrealpb.FVector rotationOffset = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotationoffset_);
    }

    // optional .unrealpb.ActorComponentRef attachComponent = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attachcomponent_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FRepAttachment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FRepAttachment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FRepAttachment::GetClassData() const { return &_class_data_; }


void FRepAttachment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FRepAttachment*>(&to_msg);
  auto& from = static_cast<const FRepAttachment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.FRepAttachment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attachsocket(from._internal_attachsocket());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_attachparent()->::unrealpb::UnrealObjectRef::MergeFrom(
          from._internal_attachparent());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_locationoffset()->::unrealpb::FVector::MergeFrom(
          from._internal_locationoffset());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_relativescale()->::unrealpb::FVector::MergeFrom(
          from._internal_relativescale());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_rotationoffset()->::unrealpb::FVector::MergeFrom(
          from._internal_rotationoffset());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_attachcomponent()->::unrealpb::ActorComponentRef::MergeFrom(
          from._internal_attachcomponent());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FRepAttachment::CopyFrom(const FRepAttachment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.FRepAttachment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FRepAttachment::IsInitialized() const {
  return true;
}

void FRepAttachment::InternalSwap(FRepAttachment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attachsocket_, lhs_arena,
      &other->_impl_.attachsocket_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FRepAttachment, _impl_.attachcomponent_)
      + sizeof(FRepAttachment::_impl_.attachcomponent_)
      - PROTOBUF_FIELD_OFFSET(FRepAttachment, _impl_.attachparent_)>(
          reinterpret_cast<char*>(&_impl_.attachparent_),
          reinterpret_cast<char*>(&other->_impl_.attachparent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FRepAttachment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[17]);
}

// ===================================================================

class ActorState::_Internal {
 public:
  using HasBits = decltype(std::declval<ActorState>()._impl_._has_bits_);
  static void set_has_owningconnid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_breplicatemovement(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_localrole(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_remoterole(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::unrealpb::UnrealObjectRef& owner(const ActorState* msg);
  static void set_has_owner(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bhidden(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_btearoff(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_bcanbedamaged(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::unrealpb::UnrealObjectRef& instigator(const ActorState* msg);
  static void set_has_instigator(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::unrealpb::FRepMovement& replicatedmovement(const ActorState* msg);
  static void set_has_replicatedmovement(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::unrealpb::FRepAttachment& attachmentreplication(const ActorState* msg);
  static void set_has_attachmentreplication(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::unrealpb::UnrealObjectRef&
ActorState::_Internal::owner(const ActorState* msg) {
  return *msg->_impl_.owner_;
}
const ::unrealpb::UnrealObjectRef&
ActorState::_Internal::instigator(const ActorState* msg) {
  return *msg->_impl_.instigator_;
}
const ::unrealpb::FRepMovement&
ActorState::_Internal::replicatedmovement(const ActorState* msg) {
  return *msg->_impl_.replicatedmovement_;
}
const ::unrealpb::FRepAttachment&
ActorState::_Internal::attachmentreplication(const ActorState* msg) {
  return *msg->_impl_.attachmentreplication_;
}
ActorState::ActorState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.ActorState)
}
ActorState::ActorState(const ActorState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActorState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_){nullptr}
    , decltype(_impl_.instigator_){nullptr}
    , decltype(_impl_.replicatedmovement_){nullptr}
    , decltype(_impl_.attachmentreplication_){nullptr}
    , decltype(_impl_.owningconnid_){}
    , decltype(_impl_.localrole_){}
    , decltype(_impl_.removed_){}
    , decltype(_impl_.breplicatemovement_){}
    , decltype(_impl_.bhidden_){}
    , decltype(_impl_.btearoff_){}
    , decltype(_impl_.remoterole_){}
    , decltype(_impl_.bcanbedamaged_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_owner()) {
    _this->_impl_.owner_ = new ::unrealpb::UnrealObjectRef(*from._impl_.owner_);
  }
  if (from._internal_has_instigator()) {
    _this->_impl_.instigator_ = new ::unrealpb::UnrealObjectRef(*from._impl_.instigator_);
  }
  if (from._internal_has_replicatedmovement()) {
    _this->_impl_.replicatedmovement_ = new ::unrealpb::FRepMovement(*from._impl_.replicatedmovement_);
  }
  if (from._internal_has_attachmentreplication()) {
    _this->_impl_.attachmentreplication_ = new ::unrealpb::FRepAttachment(*from._impl_.attachmentreplication_);
  }
  ::memcpy(&_impl_.owningconnid_, &from._impl_.owningconnid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bcanbedamaged_) -
    reinterpret_cast<char*>(&_impl_.owningconnid_)) + sizeof(_impl_.bcanbedamaged_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.ActorState)
}

inline void ActorState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.owner_){nullptr}
    , decltype(_impl_.instigator_){nullptr}
    , decltype(_impl_.replicatedmovement_){nullptr}
    , decltype(_impl_.attachmentreplication_){nullptr}
    , decltype(_impl_.owningconnid_){0u}
    , decltype(_impl_.localrole_){0u}
    , decltype(_impl_.removed_){false}
    , decltype(_impl_.breplicatemovement_){false}
    , decltype(_impl_.bhidden_){false}
    , decltype(_impl_.btearoff_){false}
    , decltype(_impl_.remoterole_){0u}
    , decltype(_impl_.bcanbedamaged_){false}
  };
}

ActorState::~ActorState() {
  // @@protoc_insertion_point(destructor:unrealpb.ActorState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActorState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.owner_;
  if (this != internal_default_instance()) delete _impl_.instigator_;
  if (this != internal_default_instance()) delete _impl_.replicatedmovement_;
  if (this != internal_default_instance()) delete _impl_.attachmentreplication_;
}

void ActorState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActorState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.ActorState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.owner_ != nullptr);
      _impl_.owner_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.instigator_ != nullptr);
      _impl_.instigator_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.replicatedmovement_ != nullptr);
      _impl_.replicatedmovement_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.attachmentreplication_ != nullptr);
      _impl_.attachmentreplication_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&_impl_.owningconnid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.localrole_) -
        reinterpret_cast<char*>(&_impl_.owningconnid_)) + sizeof(_impl_.localrole_));
  }
  _impl_.removed_ = false;
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.breplicatemovement_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bhidden_) -
        reinterpret_cast<char*>(&_impl_.breplicatemovement_)) + sizeof(_impl_.bhidden_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.btearoff_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bcanbedamaged_) -
        reinterpret_cast<char*>(&_impl_.btearoff_)) + sizeof(_impl_.bcanbedamaged_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActorState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool removed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 owningConnId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_owningconnid(&has_bits);
          _impl_.owningconnid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bReplicateMovement = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_breplicatemovement(&has_bits);
          _impl_.breplicatemovement_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 localRole = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_localrole(&has_bits);
          _impl_.localrole_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 remoteRole = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_remoterole(&has_bits);
          _impl_.remoterole_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.UnrealObjectRef owner = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_owner(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bHidden = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_bhidden(&has_bits);
          _impl_.bhidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bTearOff = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_btearoff(&has_bits);
          _impl_.btearoff_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bCanBeDamaged = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_bcanbedamaged(&has_bits);
          _impl_.bcanbedamaged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.UnrealObjectRef instigator = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_instigator(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FRepMovement replicatedMovement = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_replicatedmovement(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FRepAttachment attachmentReplication = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_attachmentreplication(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActorState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.ActorState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_removed(), target);
  }

  // optional uint32 owningConnId = 2;
  if (_internal_has_owningconnid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_owningconnid(), target);
  }

  // optional bool bReplicateMovement = 3;
  if (_internal_has_breplicatemovement()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_breplicatemovement(), target);
  }

  // optional uint32 localRole = 4;
  if (_internal_has_localrole()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_localrole(), target);
  }

  // optional uint32 remoteRole = 5;
  if (_internal_has_remoterole()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_remoterole(), target);
  }

  // optional .unrealpb.UnrealObjectRef owner = 6;
  if (_internal_has_owner()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::owner(this),
        _Internal::owner(this).GetCachedSize(), target, stream);
  }

  // optional bool bHidden = 7;
  if (_internal_has_bhidden()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_bhidden(), target);
  }

  // optional bool bTearOff = 8;
  if (_internal_has_btearoff()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_btearoff(), target);
  }

  // optional bool bCanBeDamaged = 9;
  if (_internal_has_bcanbedamaged()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_bcanbedamaged(), target);
  }

  // optional .unrealpb.UnrealObjectRef instigator = 10;
  if (_internal_has_instigator()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::instigator(this),
        _Internal::instigator(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FRepMovement replicatedMovement = 11;
  if (_internal_has_replicatedmovement()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::replicatedmovement(this),
        _Internal::replicatedmovement(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FRepAttachment attachmentReplication = 12;
  if (_internal_has_attachmentreplication()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::attachmentreplication(this),
        _Internal::attachmentreplication(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.ActorState)
  return target;
}

size_t ActorState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.ActorState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .unrealpb.UnrealObjectRef owner = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.owner_);
    }

    // optional .unrealpb.UnrealObjectRef instigator = 10;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.instigator_);
    }

    // optional .unrealpb.FRepMovement replicatedMovement = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.replicatedmovement_);
    }

    // optional .unrealpb.FRepAttachment attachmentReplication = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attachmentreplication_);
    }

    // optional uint32 owningConnId = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_owningconnid());
    }

    // optional uint32 localRole = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_localrole());
    }

  }
  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x000000c0u) {
    // optional bool bReplicateMovement = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool bHidden = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool bTearOff = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional uint32 remoteRole = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_remoterole());
    }

    // optional bool bCanBeDamaged = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActorState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActorState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActorState::GetClassData() const { return &_class_data_; }


void ActorState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActorState*>(&to_msg);
  auto& from = static_cast<const ActorState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.ActorState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_owner()->::unrealpb::UnrealObjectRef::MergeFrom(
          from._internal_owner());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_instigator()->::unrealpb::UnrealObjectRef::MergeFrom(
          from._internal_instigator());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_replicatedmovement()->::unrealpb::FRepMovement::MergeFrom(
          from._internal_replicatedmovement());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_attachmentreplication()->::unrealpb::FRepAttachment::MergeFrom(
          from._internal_attachmentreplication());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.owningconnid_ = from._impl_.owningconnid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.localrole_ = from._impl_.localrole_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  if (cached_has_bits & 0x000000c0u) {
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.breplicatemovement_ = from._impl_.breplicatemovement_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.bhidden_ = from._impl_.bhidden_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.btearoff_ = from._impl_.btearoff_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.remoterole_ = from._impl_.remoterole_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.bcanbedamaged_ = from._impl_.bcanbedamaged_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActorState::CopyFrom(const ActorState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.ActorState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorState::IsInitialized() const {
  return true;
}

void ActorState::InternalSwap(ActorState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActorState, _impl_.bcanbedamaged_)
      + sizeof(ActorState::_impl_.bcanbedamaged_)
      - PROTOBUF_FIELD_OFFSET(ActorState, _impl_.owner_)>(
          reinterpret_cast<char*>(&_impl_.owner_),
          reinterpret_cast<char*>(&other->_impl_.owner_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ActorState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[18]);
}

// ===================================================================

class ActorComponentState::_Internal {
 public:
  using HasBits = decltype(std::declval<ActorComponentState>()._impl_._has_bits_);
  static void set_has_bisactive(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_breplicated(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ActorComponentState::ActorComponentState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.ActorComponentState)
}
ActorComponentState::ActorComponentState(const ActorComponentState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ActorComponentState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.removed_){}
    , decltype(_impl_.bisactive_){}
    , decltype(_impl_.breplicated_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.removed_, &from._impl_.removed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.breplicated_) -
    reinterpret_cast<char*>(&_impl_.removed_)) + sizeof(_impl_.breplicated_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.ActorComponentState)
}

inline void ActorComponentState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.removed_){false}
    , decltype(_impl_.bisactive_){false}
    , decltype(_impl_.breplicated_){false}
  };
}

ActorComponentState::~ActorComponentState() {
  // @@protoc_insertion_point(destructor:unrealpb.ActorComponentState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ActorComponentState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ActorComponentState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ActorComponentState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.ActorComponentState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.removed_ = false;
  ::memset(&_impl_.bisactive_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.breplicated_) -
      reinterpret_cast<char*>(&_impl_.bisactive_)) + sizeof(_impl_.breplicated_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ActorComponentState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool removed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bIsActive = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bisactive(&has_bits);
          _impl_.bisactive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bReplicated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_breplicated(&has_bits);
          _impl_.breplicated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ActorComponentState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.ActorComponentState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_removed(), target);
  }

  // optional bool bIsActive = 2;
  if (_internal_has_bisactive()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_bisactive(), target);
  }

  // optional bool bReplicated = 3;
  if (_internal_has_breplicated()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_breplicated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.ActorComponentState)
  return target;
}

size_t ActorComponentState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.ActorComponentState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool bIsActive = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool bReplicated = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ActorComponentState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ActorComponentState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ActorComponentState::GetClassData() const { return &_class_data_; }


void ActorComponentState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ActorComponentState*>(&to_msg);
  auto& from = static_cast<const ActorComponentState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.ActorComponentState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.bisactive_ = from._impl_.bisactive_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.breplicated_ = from._impl_.breplicated_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ActorComponentState::CopyFrom(const ActorComponentState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.ActorComponentState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActorComponentState::IsInitialized() const {
  return true;
}

void ActorComponentState::InternalSwap(ActorComponentState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ActorComponentState, _impl_.breplicated_)
      + sizeof(ActorComponentState::_impl_.breplicated_)
      - PROTOBUF_FIELD_OFFSET(ActorComponentState, _impl_.removed_)>(
          reinterpret_cast<char*>(&_impl_.removed_),
          reinterpret_cast<char*>(&other->_impl_.removed_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ActorComponentState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[19]);
}

// ===================================================================

class SceneComponentState::_Internal {
 public:
  using HasBits = decltype(std::declval<SceneComponentState>()._impl_._has_bits_);
  static void set_has_babsolutelocation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_babsoluterotation(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_babsolutescale(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bvisible(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_bshouldbeattached(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_bshouldsnaplocationwhenattached(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_bshouldsnaprotationwhenattached(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::unrealpb::ActorComponentRef& attachparent(const SceneComponentState* msg);
  static void set_has_attachparent(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_attachsocketname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::unrealpb::FVector& relativelocation(const SceneComponentState* msg);
  static void set_has_relativelocation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::unrealpb::FVector& relativerotation(const SceneComponentState* msg);
  static void set_has_relativerotation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::unrealpb::FVector& relativescale(const SceneComponentState* msg);
  static void set_has_relativescale(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::unrealpb::ActorComponentRef&
SceneComponentState::_Internal::attachparent(const SceneComponentState* msg) {
  return *msg->_impl_.attachparent_;
}
const ::unrealpb::FVector&
SceneComponentState::_Internal::relativelocation(const SceneComponentState* msg) {
  return *msg->_impl_.relativelocation_;
}
const ::unrealpb::FVector&
SceneComponentState::_Internal::relativerotation(const SceneComponentState* msg) {
  return *msg->_impl_.relativerotation_;
}
const ::unrealpb::FVector&
SceneComponentState::_Internal::relativescale(const SceneComponentState* msg) {
  return *msg->_impl_.relativescale_;
}
SceneComponentState::SceneComponentState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.SceneComponentState)
}
SceneComponentState::SceneComponentState(const SceneComponentState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SceneComponentState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attachchildren_){from._impl_.attachchildren_}
    , decltype(_impl_.attachsocketname_){}
    , decltype(_impl_.attachparent_){nullptr}
    , decltype(_impl_.relativelocation_){nullptr}
    , decltype(_impl_.relativerotation_){nullptr}
    , decltype(_impl_.relativescale_){nullptr}
    , decltype(_impl_.removed_){}
    , decltype(_impl_.babsolutelocation_){}
    , decltype(_impl_.babsoluterotation_){}
    , decltype(_impl_.babsolutescale_){}
    , decltype(_impl_.bvisible_){}
    , decltype(_impl_.bshouldbeattached_){}
    , decltype(_impl_.bshouldsnaplocationwhenattached_){}
    , decltype(_impl_.bshouldsnaprotationwhenattached_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.attachsocketname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attachsocketname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_attachsocketname()) {
    _this->_impl_.attachsocketname_.Set(from._internal_attachsocketname(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_attachparent()) {
    _this->_impl_.attachparent_ = new ::unrealpb::ActorComponentRef(*from._impl_.attachparent_);
  }
  if (from._internal_has_relativelocation()) {
    _this->_impl_.relativelocation_ = new ::unrealpb::FVector(*from._impl_.relativelocation_);
  }
  if (from._internal_has_relativerotation()) {
    _this->_impl_.relativerotation_ = new ::unrealpb::FVector(*from._impl_.relativerotation_);
  }
  if (from._internal_has_relativescale()) {
    _this->_impl_.relativescale_ = new ::unrealpb::FVector(*from._impl_.relativescale_);
  }
  ::memcpy(&_impl_.removed_, &from._impl_.removed_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bshouldsnaprotationwhenattached_) -
    reinterpret_cast<char*>(&_impl_.removed_)) + sizeof(_impl_.bshouldsnaprotationwhenattached_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.SceneComponentState)
}

inline void SceneComponentState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.attachchildren_){arena}
    , decltype(_impl_.attachsocketname_){}
    , decltype(_impl_.attachparent_){nullptr}
    , decltype(_impl_.relativelocation_){nullptr}
    , decltype(_impl_.relativerotation_){nullptr}
    , decltype(_impl_.relativescale_){nullptr}
    , decltype(_impl_.removed_){false}
    , decltype(_impl_.babsolutelocation_){false}
    , decltype(_impl_.babsoluterotation_){false}
    , decltype(_impl_.babsolutescale_){false}
    , decltype(_impl_.bvisible_){false}
    , decltype(_impl_.bshouldbeattached_){false}
    , decltype(_impl_.bshouldsnaplocationwhenattached_){false}
    , decltype(_impl_.bshouldsnaprotationwhenattached_){false}
  };
  _impl_.attachsocketname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.attachsocketname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SceneComponentState::~SceneComponentState() {
  // @@protoc_insertion_point(destructor:unrealpb.SceneComponentState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SceneComponentState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.attachchildren_.~RepeatedPtrField();
  _impl_.attachsocketname_.Destroy();
  if (this != internal_default_instance()) delete _impl_.attachparent_;
  if (this != internal_default_instance()) delete _impl_.relativelocation_;
  if (this != internal_default_instance()) delete _impl_.relativerotation_;
  if (this != internal_default_instance()) delete _impl_.relativescale_;
}

void SceneComponentState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SceneComponentState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.SceneComponentState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.attachchildren_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.attachsocketname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.attachparent_ != nullptr);
      _impl_.attachparent_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.relativelocation_ != nullptr);
      _impl_.relativelocation_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.relativerotation_ != nullptr);
      _impl_.relativerotation_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.relativescale_ != nullptr);
      _impl_.relativescale_->Clear();
    }
  }
  _impl_.removed_ = false;
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.babsolutelocation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.babsolutescale_) -
        reinterpret_cast<char*>(&_impl_.babsolutelocation_)) + sizeof(_impl_.babsolutescale_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.bvisible_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.bshouldsnaprotationwhenattached_) -
        reinterpret_cast<char*>(&_impl_.bvisible_)) + sizeof(_impl_.bshouldsnaprotationwhenattached_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SceneComponentState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool removed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bAbsoluteLocation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_babsolutelocation(&has_bits);
          _impl_.babsolutelocation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bAbsoluteRotation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_babsoluterotation(&has_bits);
          _impl_.babsoluterotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bAbsoluteScale = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_babsolutescale(&has_bits);
          _impl_.babsolutescale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bVisible = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bvisible(&has_bits);
          _impl_.bvisible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bShouldBeAttached = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_bshouldbeattached(&has_bits);
          _impl_.bshouldbeattached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bShouldSnapLocationWhenAttached = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_bshouldsnaplocationwhenattached(&has_bits);
          _impl_.bshouldsnaplocationwhenattached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bShouldSnapRotationWhenAttached = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_bshouldsnaprotationwhenattached(&has_bits);
          _impl_.bshouldsnaprotationwhenattached_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.ActorComponentRef attachParent = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_attachparent(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .unrealpb.ActorComponentRef attachChildren = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attachchildren(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string attachSocketName = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_attachsocketname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.SceneComponentState.attachSocketName"));
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector relativeLocation = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_relativelocation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector relativeRotation = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_relativerotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector relativeScale = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_relativescale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SceneComponentState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.SceneComponentState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_removed(), target);
  }

  // optional bool bAbsoluteLocation = 2;
  if (_internal_has_babsolutelocation()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_babsolutelocation(), target);
  }

  // optional bool bAbsoluteRotation = 3;
  if (_internal_has_babsoluterotation()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_babsoluterotation(), target);
  }

  // optional bool bAbsoluteScale = 4;
  if (_internal_has_babsolutescale()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_babsolutescale(), target);
  }

  // optional bool bVisible = 5;
  if (_internal_has_bvisible()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_bvisible(), target);
  }

  // optional bool bShouldBeAttached = 6;
  if (_internal_has_bshouldbeattached()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_bshouldbeattached(), target);
  }

  // optional bool bShouldSnapLocationWhenAttached = 7;
  if (_internal_has_bshouldsnaplocationwhenattached()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_bshouldsnaplocationwhenattached(), target);
  }

  // optional bool bShouldSnapRotationWhenAttached = 8;
  if (_internal_has_bshouldsnaprotationwhenattached()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_bshouldsnaprotationwhenattached(), target);
  }

  // optional .unrealpb.ActorComponentRef attachParent = 9;
  if (_internal_has_attachparent()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::attachparent(this),
        _Internal::attachparent(this).GetCachedSize(), target, stream);
  }

  // repeated .unrealpb.ActorComponentRef attachChildren = 10;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attachchildren_size()); i < n; i++) {
    const auto& repfield = this->_internal_attachchildren(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string attachSocketName = 11;
  if (_internal_has_attachsocketname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_attachsocketname().data(), static_cast<int>(this->_internal_attachsocketname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.SceneComponentState.attachSocketName");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_attachsocketname(), target);
  }

  // optional .unrealpb.FVector relativeLocation = 12;
  if (_internal_has_relativelocation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::relativelocation(this),
        _Internal::relativelocation(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector relativeRotation = 13;
  if (_internal_has_relativerotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::relativerotation(this),
        _Internal::relativerotation(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector relativeScale = 14;
  if (_internal_has_relativescale()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::relativescale(this),
        _Internal::relativescale(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.SceneComponentState)
  return target;
}

size_t SceneComponentState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.SceneComponentState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unrealpb.ActorComponentRef attachChildren = 10;
  total_size += 1UL * this->_internal_attachchildren_size();
  for (const auto& msg : this->_impl_.attachchildren_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string attachSocketName = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_attachsocketname());
    }

    // optional .unrealpb.ActorComponentRef attachParent = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.attachparent_);
    }

    // optional .unrealpb.FVector relativeLocation = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.relativelocation_);
    }

    // optional .unrealpb.FVector relativeRotation = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.relativerotation_);
    }

    // optional .unrealpb.FVector relativeScale = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.relativescale_);
    }

  }
  // bool removed = 1;
  if (this->_internal_removed() != 0) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x000000e0u) {
    // optional bool bAbsoluteLocation = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool bAbsoluteRotation = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool bAbsoluteScale = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool bVisible = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool bShouldBeAttached = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool bShouldSnapLocationWhenAttached = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool bShouldSnapRotationWhenAttached = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SceneComponentState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SceneComponentState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SceneComponentState::GetClassData() const { return &_class_data_; }


void SceneComponentState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SceneComponentState*>(&to_msg);
  auto& from = static_cast<const SceneComponentState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.SceneComponentState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.attachchildren_.MergeFrom(from._impl_.attachchildren_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_attachsocketname(from._internal_attachsocketname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_attachparent()->::unrealpb::ActorComponentRef::MergeFrom(
          from._internal_attachparent());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_relativelocation()->::unrealpb::FVector::MergeFrom(
          from._internal_relativelocation());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_relativerotation()->::unrealpb::FVector::MergeFrom(
          from._internal_relativerotation());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_relativescale()->::unrealpb::FVector::MergeFrom(
          from._internal_relativescale());
    }
  }
  if (from._internal_removed() != 0) {
    _this->_internal_set_removed(from._internal_removed());
  }
  if (cached_has_bits & 0x000000e0u) {
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.babsolutelocation_ = from._impl_.babsolutelocation_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.babsoluterotation_ = from._impl_.babsoluterotation_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.babsolutescale_ = from._impl_.babsolutescale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.bvisible_ = from._impl_.bvisible_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.bshouldbeattached_ = from._impl_.bshouldbeattached_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.bshouldsnaplocationwhenattached_ = from._impl_.bshouldsnaplocationwhenattached_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.bshouldsnaprotationwhenattached_ = from._impl_.bshouldsnaprotationwhenattached_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SceneComponentState::CopyFrom(const SceneComponentState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.SceneComponentState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SceneComponentState::IsInitialized() const {
  return true;
}

void SceneComponentState::InternalSwap(SceneComponentState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.attachchildren_.InternalSwap(&other->_impl_.attachchildren_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.attachsocketname_, lhs_arena,
      &other->_impl_.attachsocketname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SceneComponentState, _impl_.bshouldsnaprotationwhenattached_)
      + sizeof(SceneComponentState::_impl_.bshouldsnaprotationwhenattached_)
      - PROTOBUF_FIELD_OFFSET(SceneComponentState, _impl_.attachparent_)>(
          reinterpret_cast<char*>(&_impl_.attachparent_),
          reinterpret_cast<char*>(&other->_impl_.attachparent_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SceneComponentState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[20]);
}

// ===================================================================

class FBasedMovementInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<FBasedMovementInfo>()._impl_._has_bits_);
  static const ::unrealpb::ActorComponentRef& movementbase(const FBasedMovementInfo* msg);
  static void set_has_movementbase(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bonename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::unrealpb::FVector& location(const FBasedMovementInfo* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::unrealpb::FVector& rotation(const FBasedMovementInfo* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bserverhasbasecomponent(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_brelativerotation(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_bserverhasvelocity(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::unrealpb::ActorComponentRef&
FBasedMovementInfo::_Internal::movementbase(const FBasedMovementInfo* msg) {
  return *msg->_impl_.movementbase_;
}
const ::unrealpb::FVector&
FBasedMovementInfo::_Internal::location(const FBasedMovementInfo* msg) {
  return *msg->_impl_.location_;
}
const ::unrealpb::FVector&
FBasedMovementInfo::_Internal::rotation(const FBasedMovementInfo* msg) {
  return *msg->_impl_.rotation_;
}
FBasedMovementInfo::FBasedMovementInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.FBasedMovementInfo)
}
FBasedMovementInfo::FBasedMovementInfo(const FBasedMovementInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FBasedMovementInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonename_){}
    , decltype(_impl_.movementbase_){nullptr}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.bserverhasbasecomponent_){}
    , decltype(_impl_.brelativerotation_){}
    , decltype(_impl_.bserverhasvelocity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.bonename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bonename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_bonename()) {
    _this->_impl_.bonename_.Set(from._internal_bonename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_movementbase()) {
    _this->_impl_.movementbase_ = new ::unrealpb::ActorComponentRef(*from._impl_.movementbase_);
  }
  if (from._internal_has_location()) {
    _this->_impl_.location_ = new ::unrealpb::FVector(*from._impl_.location_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::unrealpb::FVector(*from._impl_.rotation_);
  }
  ::memcpy(&_impl_.bserverhasbasecomponent_, &from._impl_.bserverhasbasecomponent_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.bserverhasvelocity_) -
    reinterpret_cast<char*>(&_impl_.bserverhasbasecomponent_)) + sizeof(_impl_.bserverhasvelocity_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.FBasedMovementInfo)
}

inline void FBasedMovementInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.bonename_){}
    , decltype(_impl_.movementbase_){nullptr}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.bserverhasbasecomponent_){false}
    , decltype(_impl_.brelativerotation_){false}
    , decltype(_impl_.bserverhasvelocity_){false}
  };
  _impl_.bonename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bonename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FBasedMovementInfo::~FBasedMovementInfo() {
  // @@protoc_insertion_point(destructor:unrealpb.FBasedMovementInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FBasedMovementInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.bonename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.movementbase_;
  if (this != internal_default_instance()) delete _impl_.location_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
}

void FBasedMovementInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FBasedMovementInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.FBasedMovementInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.bonename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.movementbase_ != nullptr);
      _impl_.movementbase_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.location_ != nullptr);
      _impl_.location_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
  }
  ::memset(&_impl_.bserverhasbasecomponent_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.bserverhasvelocity_) -
      reinterpret_cast<char*>(&_impl_.bserverhasbasecomponent_)) + sizeof(_impl_.bserverhasvelocity_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FBasedMovementInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .unrealpb.ActorComponentRef movementBase = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_movementbase(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string boneName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_bonename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.FBasedMovementInfo.boneName"));
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector rotation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bServerHasBaseComponent = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bserverhasbasecomponent(&has_bits);
          _impl_.bserverhasbasecomponent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bRelativeRotation = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_brelativerotation(&has_bits);
          _impl_.brelativerotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bServerHasVelocity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_bserverhasvelocity(&has_bits);
          _impl_.bserverhasvelocity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FBasedMovementInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.FBasedMovementInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .unrealpb.ActorComponentRef movementBase = 1;
  if (_internal_has_movementbase()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::movementbase(this),
        _Internal::movementbase(this).GetCachedSize(), target, stream);
  }

  // optional string boneName = 2;
  if (_internal_has_bonename()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_bonename().data(), static_cast<int>(this->_internal_bonename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.FBasedMovementInfo.boneName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_bonename(), target);
  }

  // optional .unrealpb.FVector location = 3;
  if (_internal_has_location()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector rotation = 4;
  if (_internal_has_rotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // optional bool bServerHasBaseComponent = 5;
  if (_internal_has_bserverhasbasecomponent()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_bserverhasbasecomponent(), target);
  }

  // optional bool bRelativeRotation = 6;
  if (_internal_has_brelativerotation()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_brelativerotation(), target);
  }

  // optional bool bServerHasVelocity = 7;
  if (_internal_has_bserverhasvelocity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_bserverhasvelocity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.FBasedMovementInfo)
  return target;
}

size_t FBasedMovementInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.FBasedMovementInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string boneName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bonename());
    }

    // optional .unrealpb.ActorComponentRef movementBase = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.movementbase_);
    }

    // optional .unrealpb.FVector location = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.location_);
    }

    // optional .unrealpb.FVector rotation = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotation_);
    }

    // optional bool bServerHasBaseComponent = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool bRelativeRotation = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool bServerHasVelocity = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FBasedMovementInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FBasedMovementInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FBasedMovementInfo::GetClassData() const { return &_class_data_; }


void FBasedMovementInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FBasedMovementInfo*>(&to_msg);
  auto& from = static_cast<const FBasedMovementInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.FBasedMovementInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_bonename(from._internal_bonename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_movementbase()->::unrealpb::ActorComponentRef::MergeFrom(
          from._internal_movementbase());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_location()->::unrealpb::FVector::MergeFrom(
          from._internal_location());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_rotation()->::unrealpb::FVector::MergeFrom(
          from._internal_rotation());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.bserverhasbasecomponent_ = from._impl_.bserverhasbasecomponent_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.brelativerotation_ = from._impl_.brelativerotation_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.bserverhasvelocity_ = from._impl_.bserverhasvelocity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FBasedMovementInfo::CopyFrom(const FBasedMovementInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.FBasedMovementInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FBasedMovementInfo::IsInitialized() const {
  return true;
}

void FBasedMovementInfo::InternalSwap(FBasedMovementInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.bonename_, lhs_arena,
      &other->_impl_.bonename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FBasedMovementInfo, _impl_.bserverhasvelocity_)
      + sizeof(FBasedMovementInfo::_impl_.bserverhasvelocity_)
      - PROTOBUF_FIELD_OFFSET(FBasedMovementInfo, _impl_.movementbase_)>(
          reinterpret_cast<char*>(&_impl_.movementbase_),
          reinterpret_cast<char*>(&other->_impl_.movementbase_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FBasedMovementInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[21]);
}

// ===================================================================

class FRootMotionSource_FRootMotionFinishVelocitySettings::_Internal {
 public:
  using HasBits = decltype(std::declval<FRootMotionSource_FRootMotionFinishVelocitySettings>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::unrealpb::FVector& setvelocity(const FRootMotionSource_FRootMotionFinishVelocitySettings* msg);
  static void set_has_setvelocity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_clampvelocity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::unrealpb::FVector&
FRootMotionSource_FRootMotionFinishVelocitySettings::_Internal::setvelocity(const FRootMotionSource_FRootMotionFinishVelocitySettings* msg) {
  return *msg->_impl_.setvelocity_;
}
FRootMotionSource_FRootMotionFinishVelocitySettings::FRootMotionSource_FRootMotionFinishVelocitySettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings)
}
FRootMotionSource_FRootMotionFinishVelocitySettings::FRootMotionSource_FRootMotionFinishVelocitySettings(const FRootMotionSource_FRootMotionFinishVelocitySettings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FRootMotionSource_FRootMotionFinishVelocitySettings* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.setvelocity_){nullptr}
    , decltype(_impl_.mode_){}
    , decltype(_impl_.clampvelocity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_setvelocity()) {
    _this->_impl_.setvelocity_ = new ::unrealpb::FVector(*from._impl_.setvelocity_);
  }
  ::memcpy(&_impl_.mode_, &from._impl_.mode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clampvelocity_) -
    reinterpret_cast<char*>(&_impl_.mode_)) + sizeof(_impl_.clampvelocity_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings)
}

inline void FRootMotionSource_FRootMotionFinishVelocitySettings::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.setvelocity_){nullptr}
    , decltype(_impl_.mode_){0u}
    , decltype(_impl_.clampvelocity_){0}
  };
}

FRootMotionSource_FRootMotionFinishVelocitySettings::~FRootMotionSource_FRootMotionFinishVelocitySettings() {
  // @@protoc_insertion_point(destructor:unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FRootMotionSource_FRootMotionFinishVelocitySettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.setvelocity_;
}

void FRootMotionSource_FRootMotionFinishVelocitySettings::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FRootMotionSource_FRootMotionFinishVelocitySettings::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.setvelocity_ != nullptr);
    _impl_.setvelocity_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.mode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.clampvelocity_) -
        reinterpret_cast<char*>(&_impl_.mode_)) + sizeof(_impl_.clampvelocity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FRootMotionSource_FRootMotionFinishVelocitySettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector setVelocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_setvelocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float clampVelocity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_clampvelocity(&has_bits);
          _impl_.clampvelocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FRootMotionSource_FRootMotionFinishVelocitySettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 mode = 1;
  if (_internal_has_mode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_mode(), target);
  }

  // optional .unrealpb.FVector setVelocity = 2;
  if (_internal_has_setvelocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::setvelocity(this),
        _Internal::setvelocity(this).GetCachedSize(), target, stream);
  }

  // optional float clampVelocity = 3;
  if (_internal_has_clampvelocity()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_clampvelocity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings)
  return target;
}

size_t FRootMotionSource_FRootMotionFinishVelocitySettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .unrealpb.FVector setVelocity = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.setvelocity_);
    }

    // optional uint32 mode = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

    // optional float clampVelocity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FRootMotionSource_FRootMotionFinishVelocitySettings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FRootMotionSource_FRootMotionFinishVelocitySettings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FRootMotionSource_FRootMotionFinishVelocitySettings::GetClassData() const { return &_class_data_; }


void FRootMotionSource_FRootMotionFinishVelocitySettings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FRootMotionSource_FRootMotionFinishVelocitySettings*>(&to_msg);
  auto& from = static_cast<const FRootMotionSource_FRootMotionFinishVelocitySettings&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_setvelocity()->::unrealpb::FVector::MergeFrom(
          from._internal_setvelocity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.clampvelocity_ = from._impl_.clampvelocity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FRootMotionSource_FRootMotionFinishVelocitySettings::CopyFrom(const FRootMotionSource_FRootMotionFinishVelocitySettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FRootMotionSource_FRootMotionFinishVelocitySettings::IsInitialized() const {
  return true;
}

void FRootMotionSource_FRootMotionFinishVelocitySettings::InternalSwap(FRootMotionSource_FRootMotionFinishVelocitySettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FRootMotionSource_FRootMotionFinishVelocitySettings, _impl_.clampvelocity_)
      + sizeof(FRootMotionSource_FRootMotionFinishVelocitySettings::_impl_.clampvelocity_)
      - PROTOBUF_FIELD_OFFSET(FRootMotionSource_FRootMotionFinishVelocitySettings, _impl_.setvelocity_)>(
          reinterpret_cast<char*>(&_impl_.setvelocity_),
          reinterpret_cast<char*>(&other->_impl_.setvelocity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FRootMotionSource_FRootMotionFinishVelocitySettings::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[22]);
}

// ===================================================================

class FRootMotionSource::_Internal {
 public:
  using HasBits = decltype(std::declval<FRootMotionSource>()._impl_._has_bits_);
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_localid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_accumulatedmode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_instancename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_starttime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_currenttime(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_previoustime(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_binlocalspace(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_bneedssimulatedcatchup(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_bsimulatedneedssmoothing(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_bhasrootmotion(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_blendweight(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings& finishvelocityparams(const FRootMotionSource* msg);
  static void set_has_finishvelocityparams(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings&
FRootMotionSource::_Internal::finishvelocityparams(const FRootMotionSource* msg) {
  return *msg->_impl_.finishvelocityparams_;
}
FRootMotionSource::FRootMotionSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.FRootMotionSource)
}
FRootMotionSource::FRootMotionSource(const FRootMotionSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FRootMotionSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.instancename_){}
    , decltype(_impl_.finishvelocityparams_){nullptr}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.localid_){}
    , decltype(_impl_.accumulatedmode_){}
    , decltype(_impl_.starttime_){}
    , decltype(_impl_.currenttime_){}
    , decltype(_impl_.previoustime_){}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.status_){}
    , decltype(_impl_.settings_){}
    , decltype(_impl_.binlocalspace_){}
    , decltype(_impl_.bneedssimulatedcatchup_){}
    , decltype(_impl_.bsimulatedneedssmoothing_){}
    , decltype(_impl_.bhasrootmotion_){}
    , decltype(_impl_.blendweight_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.instancename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instancename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_instancename()) {
    _this->_impl_.instancename_.Set(from._internal_instancename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_finishvelocityparams()) {
    _this->_impl_.finishvelocityparams_ = new ::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings(*from._impl_.finishvelocityparams_);
  }
  ::memcpy(&_impl_.priority_, &from._impl_.priority_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blendweight_) -
    reinterpret_cast<char*>(&_impl_.priority_)) + sizeof(_impl_.blendweight_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.FRootMotionSource)
}

inline void FRootMotionSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.instancename_){}
    , decltype(_impl_.finishvelocityparams_){nullptr}
    , decltype(_impl_.priority_){0u}
    , decltype(_impl_.localid_){0u}
    , decltype(_impl_.accumulatedmode_){0u}
    , decltype(_impl_.starttime_){0}
    , decltype(_impl_.currenttime_){0}
    , decltype(_impl_.previoustime_){0}
    , decltype(_impl_.duration_){0}
    , decltype(_impl_.status_){0u}
    , decltype(_impl_.settings_){0u}
    , decltype(_impl_.binlocalspace_){false}
    , decltype(_impl_.bneedssimulatedcatchup_){false}
    , decltype(_impl_.bsimulatedneedssmoothing_){false}
    , decltype(_impl_.bhasrootmotion_){false}
    , decltype(_impl_.blendweight_){0}
  };
  _impl_.instancename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instancename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FRootMotionSource::~FRootMotionSource() {
  // @@protoc_insertion_point(destructor:unrealpb.FRootMotionSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FRootMotionSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.instancename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.finishvelocityparams_;
}

void FRootMotionSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FRootMotionSource::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.FRootMotionSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.instancename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.finishvelocityparams_ != nullptr);
      _impl_.finishvelocityparams_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.priority_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.previoustime_) -
        reinterpret_cast<char*>(&_impl_.priority_)) + sizeof(_impl_.previoustime_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.duration_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.blendweight_) -
        reinterpret_cast<char*>(&_impl_.duration_)) + sizeof(_impl_.blendweight_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FRootMotionSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 priority = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_priority(&has_bits);
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 localId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_localid(&has_bits);
          _impl_.localid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 accumulatedMode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_accumulatedmode(&has_bits);
          _impl_.accumulatedmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string instanceName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_instancename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.FRootMotionSource.instanceName"));
        } else
          goto handle_unusual;
        continue;
      // optional float startTime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_starttime(&has_bits);
          _impl_.starttime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float currentTime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_currenttime(&has_bits);
          _impl_.currenttime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float previousTime = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_previoustime(&has_bits);
          _impl_.previoustime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float duration = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_duration(&has_bits);
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 status = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_status(&has_bits);
          _impl_.status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 settings = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_settings(&has_bits);
          _impl_.settings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bInLocalSpace = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_binlocalspace(&has_bits);
          _impl_.binlocalspace_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bNeedsSimulatedCatchup = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_bneedssimulatedcatchup(&has_bits);
          _impl_.bneedssimulatedcatchup_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bSimulatedNeedsSmoothing = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_bsimulatedneedssmoothing(&has_bits);
          _impl_.bsimulatedneedssmoothing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bHasRootMotion = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_bhasrootmotion(&has_bits);
          _impl_.bhasrootmotion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float blendWeight = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_blendweight(&has_bits);
          _impl_.blendweight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings finishVelocityParams = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_finishvelocityparams(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FRootMotionSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.FRootMotionSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional uint32 priority = 1;
  if (_internal_has_priority()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_priority(), target);
  }

  // optional uint32 localId = 2;
  if (_internal_has_localid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_localid(), target);
  }

  // optional uint32 accumulatedMode = 3;
  if (_internal_has_accumulatedmode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_accumulatedmode(), target);
  }

  // optional string instanceName = 4;
  if (_internal_has_instancename()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_instancename().data(), static_cast<int>(this->_internal_instancename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.FRootMotionSource.instanceName");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_instancename(), target);
  }

  // optional float startTime = 5;
  if (_internal_has_starttime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_starttime(), target);
  }

  // optional float currentTime = 6;
  if (_internal_has_currenttime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_currenttime(), target);
  }

  // optional float previousTime = 7;
  if (_internal_has_previoustime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_previoustime(), target);
  }

  // optional float duration = 8;
  if (_internal_has_duration()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_duration(), target);
  }

  // optional uint32 status = 9;
  if (_internal_has_status()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_status(), target);
  }

  // optional uint32 settings = 10;
  if (_internal_has_settings()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_settings(), target);
  }

  // optional bool bInLocalSpace = 11;
  if (_internal_has_binlocalspace()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_binlocalspace(), target);
  }

  // optional bool bNeedsSimulatedCatchup = 12;
  if (_internal_has_bneedssimulatedcatchup()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_bneedssimulatedcatchup(), target);
  }

  // optional bool bSimulatedNeedsSmoothing = 13;
  if (_internal_has_bsimulatedneedssmoothing()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_bsimulatedneedssmoothing(), target);
  }

  // optional bool bHasRootMotion = 14;
  if (_internal_has_bhasrootmotion()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_bhasrootmotion(), target);
  }

  // optional float blendWeight = 15;
  if (_internal_has_blendweight()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_blendweight(), target);
  }

  // optional .unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings finishVelocityParams = 16;
  if (_internal_has_finishvelocityparams()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::finishvelocityparams(this),
        _Internal::finishvelocityparams(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.FRootMotionSource)
  return target;
}

size_t FRootMotionSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.FRootMotionSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string instanceName = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_instancename());
    }

    // optional .unrealpb.FRootMotionSource.FRootMotionFinishVelocitySettings finishVelocityParams = 16;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.finishvelocityparams_);
    }

    // optional uint32 priority = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_priority());
    }

    // optional uint32 localId = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_localid());
    }

    // optional uint32 accumulatedMode = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_accumulatedmode());
    }

    // optional float startTime = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float currentTime = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float previousTime = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float duration = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional uint32 status = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status());
    }

    // optional uint32 settings = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_settings());
    }

    // optional bool bInLocalSpace = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool bNeedsSimulatedCatchup = 12;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool bSimulatedNeedsSmoothing = 13;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool bHasRootMotion = 14;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional float blendWeight = 15;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FRootMotionSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FRootMotionSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FRootMotionSource::GetClassData() const { return &_class_data_; }


void FRootMotionSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FRootMotionSource*>(&to_msg);
  auto& from = static_cast<const FRootMotionSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.FRootMotionSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_instancename(from._internal_instancename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_finishvelocityparams()->::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings::MergeFrom(
          from._internal_finishvelocityparams());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.priority_ = from._impl_.priority_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.localid_ = from._impl_.localid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.accumulatedmode_ = from._impl_.accumulatedmode_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.starttime_ = from._impl_.starttime_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.currenttime_ = from._impl_.currenttime_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.previoustime_ = from._impl_.previoustime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.duration_ = from._impl_.duration_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.status_ = from._impl_.status_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.settings_ = from._impl_.settings_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.binlocalspace_ = from._impl_.binlocalspace_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.bneedssimulatedcatchup_ = from._impl_.bneedssimulatedcatchup_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.bsimulatedneedssmoothing_ = from._impl_.bsimulatedneedssmoothing_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.bhasrootmotion_ = from._impl_.bhasrootmotion_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.blendweight_ = from._impl_.blendweight_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FRootMotionSource::CopyFrom(const FRootMotionSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.FRootMotionSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FRootMotionSource::IsInitialized() const {
  return true;
}

void FRootMotionSource::InternalSwap(FRootMotionSource* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.instancename_, lhs_arena,
      &other->_impl_.instancename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FRootMotionSource, _impl_.blendweight_)
      + sizeof(FRootMotionSource::_impl_.blendweight_)
      - PROTOBUF_FIELD_OFFSET(FRootMotionSource, _impl_.finishvelocityparams_)>(
          reinterpret_cast<char*>(&_impl_.finishvelocityparams_),
          reinterpret_cast<char*>(&other->_impl_.finishvelocityparams_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FRootMotionSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[23]);
}

// ===================================================================

class FRootMotionSourceGroup::_Internal {
 public:
  using HasBits = decltype(std::declval<FRootMotionSourceGroup>()._impl_._has_bits_);
  static void set_has_bhasadditivesources(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bhasoverridesources(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bhasoverridesourceswithignorezaccumulate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bisadditivevelocityapplied(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_lastaccumulatedsettings(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::unrealpb::FVector& lastpreadditivevelocity(const FRootMotionSourceGroup* msg);
  static void set_has_lastpreadditivevelocity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::unrealpb::FVector&
FRootMotionSourceGroup::_Internal::lastpreadditivevelocity(const FRootMotionSourceGroup* msg) {
  return *msg->_impl_.lastpreadditivevelocity_;
}
FRootMotionSourceGroup::FRootMotionSourceGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.FRootMotionSourceGroup)
}
FRootMotionSourceGroup::FRootMotionSourceGroup(const FRootMotionSourceGroup& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FRootMotionSourceGroup* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rootmotionsources_){from._impl_.rootmotionsources_}
    , decltype(_impl_.pendingaddrootmotionsources_){from._impl_.pendingaddrootmotionsources_}
    , decltype(_impl_.lastpreadditivevelocity_){nullptr}
    , decltype(_impl_.bhasadditivesources_){}
    , decltype(_impl_.bhasoverridesources_){}
    , decltype(_impl_.bhasoverridesourceswithignorezaccumulate_){}
    , decltype(_impl_.bisadditivevelocityapplied_){}
    , decltype(_impl_.lastaccumulatedsettings_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_lastpreadditivevelocity()) {
    _this->_impl_.lastpreadditivevelocity_ = new ::unrealpb::FVector(*from._impl_.lastpreadditivevelocity_);
  }
  ::memcpy(&_impl_.bhasadditivesources_, &from._impl_.bhasadditivesources_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lastaccumulatedsettings_) -
    reinterpret_cast<char*>(&_impl_.bhasadditivesources_)) + sizeof(_impl_.lastaccumulatedsettings_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.FRootMotionSourceGroup)
}

inline void FRootMotionSourceGroup::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rootmotionsources_){arena}
    , decltype(_impl_.pendingaddrootmotionsources_){arena}
    , decltype(_impl_.lastpreadditivevelocity_){nullptr}
    , decltype(_impl_.bhasadditivesources_){false}
    , decltype(_impl_.bhasoverridesources_){false}
    , decltype(_impl_.bhasoverridesourceswithignorezaccumulate_){false}
    , decltype(_impl_.bisadditivevelocityapplied_){false}
    , decltype(_impl_.lastaccumulatedsettings_){0u}
  };
}

FRootMotionSourceGroup::~FRootMotionSourceGroup() {
  // @@protoc_insertion_point(destructor:unrealpb.FRootMotionSourceGroup)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FRootMotionSourceGroup::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.rootmotionsources_.~RepeatedPtrField();
  _impl_.pendingaddrootmotionsources_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.lastpreadditivevelocity_;
}

void FRootMotionSourceGroup::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FRootMotionSourceGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.FRootMotionSourceGroup)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.rootmotionsources_.Clear();
  _impl_.pendingaddrootmotionsources_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.lastpreadditivevelocity_ != nullptr);
    _impl_.lastpreadditivevelocity_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.bhasadditivesources_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.lastaccumulatedsettings_) -
        reinterpret_cast<char*>(&_impl_.bhasadditivesources_)) + sizeof(_impl_.lastaccumulatedsettings_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FRootMotionSourceGroup::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .unrealpb.FRootMotionSource rootMotionSources = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rootmotionsources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .unrealpb.FRootMotionSource pendingAddRootMotionSources = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pendingaddrootmotionsources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool bHasAdditiveSources = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bhasadditivesources(&has_bits);
          _impl_.bhasadditivesources_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bHasOverrideSources = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_bhasoverridesources(&has_bits);
          _impl_.bhasoverridesources_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bHasOverrideSourcesWithIgnoreZAccumulate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bhasoverridesourceswithignorezaccumulate(&has_bits);
          _impl_.bhasoverridesourceswithignorezaccumulate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bIsAdditiveVelocityApplied = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_bisadditivevelocityapplied(&has_bits);
          _impl_.bisadditivevelocityapplied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 lastAccumulatedSettings = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_lastaccumulatedsettings(&has_bits);
          _impl_.lastaccumulatedsettings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector lastPreAdditiveVelocity = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_lastpreadditivevelocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FRootMotionSourceGroup::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.FRootMotionSourceGroup)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .unrealpb.FRootMotionSource rootMotionSources = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rootmotionsources_size()); i < n; i++) {
    const auto& repfield = this->_internal_rootmotionsources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .unrealpb.FRootMotionSource pendingAddRootMotionSources = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pendingaddrootmotionsources_size()); i < n; i++) {
    const auto& repfield = this->_internal_pendingaddrootmotionsources(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool bHasAdditiveSources = 3;
  if (_internal_has_bhasadditivesources()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_bhasadditivesources(), target);
  }

  // optional bool bHasOverrideSources = 4;
  if (_internal_has_bhasoverridesources()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_bhasoverridesources(), target);
  }

  // optional bool bHasOverrideSourcesWithIgnoreZAccumulate = 5;
  if (_internal_has_bhasoverridesourceswithignorezaccumulate()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_bhasoverridesourceswithignorezaccumulate(), target);
  }

  // optional bool bIsAdditiveVelocityApplied = 6;
  if (_internal_has_bisadditivevelocityapplied()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_bisadditivevelocityapplied(), target);
  }

  // optional uint32 lastAccumulatedSettings = 7;
  if (_internal_has_lastaccumulatedsettings()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_lastaccumulatedsettings(), target);
  }

  // optional .unrealpb.FVector lastPreAdditiveVelocity = 8;
  if (_internal_has_lastpreadditivevelocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::lastpreadditivevelocity(this),
        _Internal::lastpreadditivevelocity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.FRootMotionSourceGroup)
  return target;
}

size_t FRootMotionSourceGroup::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.FRootMotionSourceGroup)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .unrealpb.FRootMotionSource rootMotionSources = 1;
  total_size += 1UL * this->_internal_rootmotionsources_size();
  for (const auto& msg : this->_impl_.rootmotionsources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .unrealpb.FRootMotionSource pendingAddRootMotionSources = 2;
  total_size += 1UL * this->_internal_pendingaddrootmotionsources_size();
  for (const auto& msg : this->_impl_.pendingaddrootmotionsources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .unrealpb.FVector lastPreAdditiveVelocity = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.lastpreadditivevelocity_);
    }

    // optional bool bHasAdditiveSources = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool bHasOverrideSources = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool bHasOverrideSourcesWithIgnoreZAccumulate = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool bIsAdditiveVelocityApplied = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint32 lastAccumulatedSettings = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_lastaccumulatedsettings());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FRootMotionSourceGroup::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FRootMotionSourceGroup::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FRootMotionSourceGroup::GetClassData() const { return &_class_data_; }


void FRootMotionSourceGroup::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FRootMotionSourceGroup*>(&to_msg);
  auto& from = static_cast<const FRootMotionSourceGroup&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.FRootMotionSourceGroup)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.rootmotionsources_.MergeFrom(from._impl_.rootmotionsources_);
  _this->_impl_.pendingaddrootmotionsources_.MergeFrom(from._impl_.pendingaddrootmotionsources_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_lastpreadditivevelocity()->::unrealpb::FVector::MergeFrom(
          from._internal_lastpreadditivevelocity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bhasadditivesources_ = from._impl_.bhasadditivesources_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bhasoverridesources_ = from._impl_.bhasoverridesources_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.bhasoverridesourceswithignorezaccumulate_ = from._impl_.bhasoverridesourceswithignorezaccumulate_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.bisadditivevelocityapplied_ = from._impl_.bisadditivevelocityapplied_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.lastaccumulatedsettings_ = from._impl_.lastaccumulatedsettings_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FRootMotionSourceGroup::CopyFrom(const FRootMotionSourceGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.FRootMotionSourceGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FRootMotionSourceGroup::IsInitialized() const {
  return true;
}

void FRootMotionSourceGroup::InternalSwap(FRootMotionSourceGroup* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.rootmotionsources_.InternalSwap(&other->_impl_.rootmotionsources_);
  _impl_.pendingaddrootmotionsources_.InternalSwap(&other->_impl_.pendingaddrootmotionsources_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FRootMotionSourceGroup, _impl_.lastaccumulatedsettings_)
      + sizeof(FRootMotionSourceGroup::_impl_.lastaccumulatedsettings_)
      - PROTOBUF_FIELD_OFFSET(FRootMotionSourceGroup, _impl_.lastpreadditivevelocity_)>(
          reinterpret_cast<char*>(&_impl_.lastpreadditivevelocity_),
          reinterpret_cast<char*>(&other->_impl_.lastpreadditivevelocity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FRootMotionSourceGroup::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[24]);
}

// ===================================================================

class FRepRootMotionMontage::_Internal {
 public:
  using HasBits = decltype(std::declval<FRepRootMotionMontage>()._impl_._has_bits_);
  static void set_has_bisactive(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::unrealpb::UnrealObjectRef& animmontage(const FRepRootMotionMontage* msg);
  static void set_has_animmontage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_position(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::unrealpb::FVector& location(const FRepRootMotionMontage* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::unrealpb::FVector& rotation(const FRepRootMotionMontage* msg);
  static void set_has_rotation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::unrealpb::ActorComponentRef& movementbase(const FRepRootMotionMontage* msg);
  static void set_has_movementbase(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_movementbasebonename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_brelativeposition(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_brelativerotation(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::unrealpb::FRootMotionSourceGroup& authoritativerootmotion(const FRepRootMotionMontage* msg);
  static void set_has_authoritativerootmotion(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::unrealpb::FVector& acceleration(const FRepRootMotionMontage* msg);
  static void set_has_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::unrealpb::FVector& linearvelocity(const FRepRootMotionMontage* msg);
  static void set_has_linearvelocity(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::unrealpb::UnrealObjectRef&
FRepRootMotionMontage::_Internal::animmontage(const FRepRootMotionMontage* msg) {
  return *msg->_impl_.animmontage_;
}
const ::unrealpb::FVector&
FRepRootMotionMontage::_Internal::location(const FRepRootMotionMontage* msg) {
  return *msg->_impl_.location_;
}
const ::unrealpb::FVector&
FRepRootMotionMontage::_Internal::rotation(const FRepRootMotionMontage* msg) {
  return *msg->_impl_.rotation_;
}
const ::unrealpb::ActorComponentRef&
FRepRootMotionMontage::_Internal::movementbase(const FRepRootMotionMontage* msg) {
  return *msg->_impl_.movementbase_;
}
const ::unrealpb::FRootMotionSourceGroup&
FRepRootMotionMontage::_Internal::authoritativerootmotion(const FRepRootMotionMontage* msg) {
  return *msg->_impl_.authoritativerootmotion_;
}
const ::unrealpb::FVector&
FRepRootMotionMontage::_Internal::acceleration(const FRepRootMotionMontage* msg) {
  return *msg->_impl_.acceleration_;
}
const ::unrealpb::FVector&
FRepRootMotionMontage::_Internal::linearvelocity(const FRepRootMotionMontage* msg) {
  return *msg->_impl_.linearvelocity_;
}
FRepRootMotionMontage::FRepRootMotionMontage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.FRepRootMotionMontage)
}
FRepRootMotionMontage::FRepRootMotionMontage(const FRepRootMotionMontage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FRepRootMotionMontage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.movementbasebonename_){}
    , decltype(_impl_.animmontage_){nullptr}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.movementbase_){nullptr}
    , decltype(_impl_.authoritativerootmotion_){nullptr}
    , decltype(_impl_.acceleration_){nullptr}
    , decltype(_impl_.linearvelocity_){nullptr}
    , decltype(_impl_.position_){}
    , decltype(_impl_.bisactive_){}
    , decltype(_impl_.brelativeposition_){}
    , decltype(_impl_.brelativerotation_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.movementbasebonename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.movementbasebonename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_movementbasebonename()) {
    _this->_impl_.movementbasebonename_.Set(from._internal_movementbasebonename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_animmontage()) {
    _this->_impl_.animmontage_ = new ::unrealpb::UnrealObjectRef(*from._impl_.animmontage_);
  }
  if (from._internal_has_location()) {
    _this->_impl_.location_ = new ::unrealpb::FVector(*from._impl_.location_);
  }
  if (from._internal_has_rotation()) {
    _this->_impl_.rotation_ = new ::unrealpb::FVector(*from._impl_.rotation_);
  }
  if (from._internal_has_movementbase()) {
    _this->_impl_.movementbase_ = new ::unrealpb::ActorComponentRef(*from._impl_.movementbase_);
  }
  if (from._internal_has_authoritativerootmotion()) {
    _this->_impl_.authoritativerootmotion_ = new ::unrealpb::FRootMotionSourceGroup(*from._impl_.authoritativerootmotion_);
  }
  if (from._internal_has_acceleration()) {
    _this->_impl_.acceleration_ = new ::unrealpb::FVector(*from._impl_.acceleration_);
  }
  if (from._internal_has_linearvelocity()) {
    _this->_impl_.linearvelocity_ = new ::unrealpb::FVector(*from._impl_.linearvelocity_);
  }
  ::memcpy(&_impl_.position_, &from._impl_.position_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.brelativerotation_) -
    reinterpret_cast<char*>(&_impl_.position_)) + sizeof(_impl_.brelativerotation_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.FRepRootMotionMontage)
}

inline void FRepRootMotionMontage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.movementbasebonename_){}
    , decltype(_impl_.animmontage_){nullptr}
    , decltype(_impl_.location_){nullptr}
    , decltype(_impl_.rotation_){nullptr}
    , decltype(_impl_.movementbase_){nullptr}
    , decltype(_impl_.authoritativerootmotion_){nullptr}
    , decltype(_impl_.acceleration_){nullptr}
    , decltype(_impl_.linearvelocity_){nullptr}
    , decltype(_impl_.position_){0}
    , decltype(_impl_.bisactive_){false}
    , decltype(_impl_.brelativeposition_){false}
    , decltype(_impl_.brelativerotation_){false}
  };
  _impl_.movementbasebonename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.movementbasebonename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FRepRootMotionMontage::~FRepRootMotionMontage() {
  // @@protoc_insertion_point(destructor:unrealpb.FRepRootMotionMontage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FRepRootMotionMontage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.movementbasebonename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.animmontage_;
  if (this != internal_default_instance()) delete _impl_.location_;
  if (this != internal_default_instance()) delete _impl_.rotation_;
  if (this != internal_default_instance()) delete _impl_.movementbase_;
  if (this != internal_default_instance()) delete _impl_.authoritativerootmotion_;
  if (this != internal_default_instance()) delete _impl_.acceleration_;
  if (this != internal_default_instance()) delete _impl_.linearvelocity_;
}

void FRepRootMotionMontage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FRepRootMotionMontage::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.FRepRootMotionMontage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.movementbasebonename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.animmontage_ != nullptr);
      _impl_.animmontage_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.location_ != nullptr);
      _impl_.location_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.rotation_ != nullptr);
      _impl_.rotation_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.movementbase_ != nullptr);
      _impl_.movementbase_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.authoritativerootmotion_ != nullptr);
      _impl_.authoritativerootmotion_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.acceleration_ != nullptr);
      _impl_.acceleration_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.linearvelocity_ != nullptr);
      _impl_.linearvelocity_->Clear();
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.position_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.brelativerotation_) -
        reinterpret_cast<char*>(&_impl_.position_)) + sizeof(_impl_.brelativerotation_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FRepRootMotionMontage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool bIsActive = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_bisactive(&has_bits);
          _impl_.bisactive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.UnrealObjectRef animMontage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_animmontage(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_position(&has_bits);
          _impl_.position_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector location = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_location(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector rotation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.ActorComponentRef movementBase = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_movementbase(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string movementBaseBoneName = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_movementbasebonename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.FRepRootMotionMontage.movementBaseBoneName"));
        } else
          goto handle_unusual;
        continue;
      // optional bool bRelativePosition = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_brelativeposition(&has_bits);
          _impl_.brelativeposition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bRelativeRotation = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_brelativerotation(&has_bits);
          _impl_.brelativerotation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FRootMotionSourceGroup authoritativeRootMotion = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_authoritativerootmotion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector acceleration = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_acceleration(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector linearVelocity = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_linearvelocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FRepRootMotionMontage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.FRepRootMotionMontage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool bIsActive = 1;
  if (_internal_has_bisactive()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_bisactive(), target);
  }

  // optional .unrealpb.UnrealObjectRef animMontage = 2;
  if (_internal_has_animmontage()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::animmontage(this),
        _Internal::animmontage(this).GetCachedSize(), target, stream);
  }

  // optional float position = 3;
  if (_internal_has_position()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_position(), target);
  }

  // optional .unrealpb.FVector location = 4;
  if (_internal_has_location()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::location(this),
        _Internal::location(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector rotation = 5;
  if (_internal_has_rotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::rotation(this),
        _Internal::rotation(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.ActorComponentRef movementBase = 6;
  if (_internal_has_movementbase()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::movementbase(this),
        _Internal::movementbase(this).GetCachedSize(), target, stream);
  }

  // optional string movementBaseBoneName = 7;
  if (_internal_has_movementbasebonename()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_movementbasebonename().data(), static_cast<int>(this->_internal_movementbasebonename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.FRepRootMotionMontage.movementBaseBoneName");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_movementbasebonename(), target);
  }

  // optional bool bRelativePosition = 8;
  if (_internal_has_brelativeposition()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_brelativeposition(), target);
  }

  // optional bool bRelativeRotation = 9;
  if (_internal_has_brelativerotation()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_brelativerotation(), target);
  }

  // optional .unrealpb.FRootMotionSourceGroup authoritativeRootMotion = 10;
  if (_internal_has_authoritativerootmotion()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::authoritativerootmotion(this),
        _Internal::authoritativerootmotion(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector acceleration = 11;
  if (_internal_has_acceleration()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::acceleration(this),
        _Internal::acceleration(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector linearVelocity = 12;
  if (_internal_has_linearvelocity()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::linearvelocity(this),
        _Internal::linearvelocity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.FRepRootMotionMontage)
  return target;
}

size_t FRepRootMotionMontage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.FRepRootMotionMontage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string movementBaseBoneName = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_movementbasebonename());
    }

    // optional .unrealpb.UnrealObjectRef animMontage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.animmontage_);
    }

    // optional .unrealpb.FVector location = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.location_);
    }

    // optional .unrealpb.FVector rotation = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rotation_);
    }

    // optional .unrealpb.ActorComponentRef movementBase = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.movementbase_);
    }

    // optional .unrealpb.FRootMotionSourceGroup authoritativeRootMotion = 10;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.authoritativerootmotion_);
    }

    // optional .unrealpb.FVector acceleration = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.acceleration_);
    }

    // optional .unrealpb.FVector linearVelocity = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.linearvelocity_);
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional float position = 3;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional bool bIsActive = 1;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool bRelativePosition = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool bRelativeRotation = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FRepRootMotionMontage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FRepRootMotionMontage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FRepRootMotionMontage::GetClassData() const { return &_class_data_; }


void FRepRootMotionMontage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FRepRootMotionMontage*>(&to_msg);
  auto& from = static_cast<const FRepRootMotionMontage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.FRepRootMotionMontage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_movementbasebonename(from._internal_movementbasebonename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_animmontage()->::unrealpb::UnrealObjectRef::MergeFrom(
          from._internal_animmontage());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_location()->::unrealpb::FVector::MergeFrom(
          from._internal_location());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_rotation()->::unrealpb::FVector::MergeFrom(
          from._internal_rotation());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_movementbase()->::unrealpb::ActorComponentRef::MergeFrom(
          from._internal_movementbase());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_authoritativerootmotion()->::unrealpb::FRootMotionSourceGroup::MergeFrom(
          from._internal_authoritativerootmotion());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_acceleration()->::unrealpb::FVector::MergeFrom(
          from._internal_acceleration());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_linearvelocity()->::unrealpb::FVector::MergeFrom(
          from._internal_linearvelocity());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.position_ = from._impl_.position_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.bisactive_ = from._impl_.bisactive_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.brelativeposition_ = from._impl_.brelativeposition_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.brelativerotation_ = from._impl_.brelativerotation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FRepRootMotionMontage::CopyFrom(const FRepRootMotionMontage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.FRepRootMotionMontage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FRepRootMotionMontage::IsInitialized() const {
  return true;
}

void FRepRootMotionMontage::InternalSwap(FRepRootMotionMontage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.movementbasebonename_, lhs_arena,
      &other->_impl_.movementbasebonename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FRepRootMotionMontage, _impl_.brelativerotation_)
      + sizeof(FRepRootMotionMontage::_impl_.brelativerotation_)
      - PROTOBUF_FIELD_OFFSET(FRepRootMotionMontage, _impl_.animmontage_)>(
          reinterpret_cast<char*>(&_impl_.animmontage_),
          reinterpret_cast<char*>(&other->_impl_.animmontage_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FRepRootMotionMontage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[25]);
}

// ===================================================================

class CharacterState::_Internal {
 public:
  using HasBits = decltype(std::declval<CharacterState>()._impl_._has_bits_);
  static const ::unrealpb::FRepRootMotionMontage& rootmotion(const CharacterState* msg);
  static void set_has_rootmotion(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::unrealpb::FBasedMovementInfo& basedmovement(const CharacterState* msg);
  static void set_has_basedmovement(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_serverlasttransformupdatetimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_movementmode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_biscrouched(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_bproxyisjumpforceapplied(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_animrootmotiontranslationscale(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_replaylasttransformupdatetimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::unrealpb::FRepRootMotionMontage&
CharacterState::_Internal::rootmotion(const CharacterState* msg) {
  return *msg->_impl_.rootmotion_;
}
const ::unrealpb::FBasedMovementInfo&
CharacterState::_Internal::basedmovement(const CharacterState* msg) {
  return *msg->_impl_.basedmovement_;
}
CharacterState::CharacterState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.CharacterState)
}
CharacterState::CharacterState(const CharacterState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CharacterState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rootmotion_){nullptr}
    , decltype(_impl_.basedmovement_){nullptr}
    , decltype(_impl_.serverlasttransformupdatetimestamp_){}
    , decltype(_impl_.movementmode_){}
    , decltype(_impl_.biscrouched_){}
    , decltype(_impl_.bproxyisjumpforceapplied_){}
    , decltype(_impl_.animrootmotiontranslationscale_){}
    , decltype(_impl_.replaylasttransformupdatetimestamp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rootmotion()) {
    _this->_impl_.rootmotion_ = new ::unrealpb::FRepRootMotionMontage(*from._impl_.rootmotion_);
  }
  if (from._internal_has_basedmovement()) {
    _this->_impl_.basedmovement_ = new ::unrealpb::FBasedMovementInfo(*from._impl_.basedmovement_);
  }
  ::memcpy(&_impl_.serverlasttransformupdatetimestamp_, &from._impl_.serverlasttransformupdatetimestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.replaylasttransformupdatetimestamp_) -
    reinterpret_cast<char*>(&_impl_.serverlasttransformupdatetimestamp_)) + sizeof(_impl_.replaylasttransformupdatetimestamp_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.CharacterState)
}

inline void CharacterState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rootmotion_){nullptr}
    , decltype(_impl_.basedmovement_){nullptr}
    , decltype(_impl_.serverlasttransformupdatetimestamp_){0}
    , decltype(_impl_.movementmode_){0u}
    , decltype(_impl_.biscrouched_){false}
    , decltype(_impl_.bproxyisjumpforceapplied_){false}
    , decltype(_impl_.animrootmotiontranslationscale_){0}
    , decltype(_impl_.replaylasttransformupdatetimestamp_){0}
  };
}

CharacterState::~CharacterState() {
  // @@protoc_insertion_point(destructor:unrealpb.CharacterState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CharacterState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rootmotion_;
  if (this != internal_default_instance()) delete _impl_.basedmovement_;
}

void CharacterState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CharacterState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.CharacterState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.rootmotion_ != nullptr);
      _impl_.rootmotion_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.basedmovement_ != nullptr);
      _impl_.basedmovement_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.serverlasttransformupdatetimestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.replaylasttransformupdatetimestamp_) -
        reinterpret_cast<char*>(&_impl_.serverlasttransformupdatetimestamp_)) + sizeof(_impl_.replaylasttransformupdatetimestamp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CharacterState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .unrealpb.FRepRootMotionMontage rootMotion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rootmotion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FBasedMovementInfo basedMovement = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_basedmovement(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float serverLastTransformUpdateTimeStamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_serverlasttransformupdatetimestamp(&has_bits);
          _impl_.serverlasttransformupdatetimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 movementMode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_movementmode(&has_bits);
          _impl_.movementmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bIsCrouched = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_biscrouched(&has_bits);
          _impl_.biscrouched_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bProxyIsJumpForceApplied = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_bproxyisjumpforceapplied(&has_bits);
          _impl_.bproxyisjumpforceapplied_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float animRootMotionTranslationScale = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_animrootmotiontranslationscale(&has_bits);
          _impl_.animrootmotiontranslationscale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float replayLastTransformUpdateTimeStamp = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_replaylasttransformupdatetimestamp(&has_bits);
          _impl_.replaylasttransformupdatetimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CharacterState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.CharacterState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .unrealpb.FRepRootMotionMontage rootMotion = 2;
  if (_internal_has_rootmotion()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rootmotion(this),
        _Internal::rootmotion(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FBasedMovementInfo basedMovement = 3;
  if (_internal_has_basedmovement()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::basedmovement(this),
        _Internal::basedmovement(this).GetCachedSize(), target, stream);
  }

  // optional float serverLastTransformUpdateTimeStamp = 4;
  if (_internal_has_serverlasttransformupdatetimestamp()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_serverlasttransformupdatetimestamp(), target);
  }

  // optional uint32 movementMode = 5;
  if (_internal_has_movementmode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_movementmode(), target);
  }

  // optional bool bIsCrouched = 6;
  if (_internal_has_biscrouched()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_biscrouched(), target);
  }

  // optional bool bProxyIsJumpForceApplied = 7;
  if (_internal_has_bproxyisjumpforceapplied()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_bproxyisjumpforceapplied(), target);
  }

  // optional float animRootMotionTranslationScale = 8;
  if (_internal_has_animrootmotiontranslationscale()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_animrootmotiontranslationscale(), target);
  }

  // optional float replayLastTransformUpdateTimeStamp = 9;
  if (_internal_has_replaylasttransformupdatetimestamp()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_replaylasttransformupdatetimestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.CharacterState)
  return target;
}

size_t CharacterState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.CharacterState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .unrealpb.FRepRootMotionMontage rootMotion = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rootmotion_);
    }

    // optional .unrealpb.FBasedMovementInfo basedMovement = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.basedmovement_);
    }

    // optional float serverLastTransformUpdateTimeStamp = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 movementMode = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_movementmode());
    }

    // optional bool bIsCrouched = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool bProxyIsJumpForceApplied = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional float animRootMotionTranslationScale = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float replayLastTransformUpdateTimeStamp = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CharacterState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CharacterState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CharacterState::GetClassData() const { return &_class_data_; }


void CharacterState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CharacterState*>(&to_msg);
  auto& from = static_cast<const CharacterState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.CharacterState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_rootmotion()->::unrealpb::FRepRootMotionMontage::MergeFrom(
          from._internal_rootmotion());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_basedmovement()->::unrealpb::FBasedMovementInfo::MergeFrom(
          from._internal_basedmovement());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.serverlasttransformupdatetimestamp_ = from._impl_.serverlasttransformupdatetimestamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.movementmode_ = from._impl_.movementmode_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.biscrouched_ = from._impl_.biscrouched_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.bproxyisjumpforceapplied_ = from._impl_.bproxyisjumpforceapplied_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.animrootmotiontranslationscale_ = from._impl_.animrootmotiontranslationscale_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.replaylasttransformupdatetimestamp_ = from._impl_.replaylasttransformupdatetimestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CharacterState::CopyFrom(const CharacterState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.CharacterState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CharacterState::IsInitialized() const {
  return true;
}

void CharacterState::InternalSwap(CharacterState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CharacterState, _impl_.replaylasttransformupdatetimestamp_)
      + sizeof(CharacterState::_impl_.replaylasttransformupdatetimestamp_)
      - PROTOBUF_FIELD_OFFSET(CharacterState, _impl_.rootmotion_)>(
          reinterpret_cast<char*>(&_impl_.rootmotion_),
          reinterpret_cast<char*>(&other->_impl_.rootmotion_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CharacterState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[26]);
}

// ===================================================================

class Character_ServerMovePacked_Params::_Internal {
 public:
};

Character_ServerMovePacked_Params::Character_ServerMovePacked_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.Character_ServerMovePacked_Params)
}
Character_ServerMovePacked_Params::Character_ServerMovePacked_Params(const Character_ServerMovePacked_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Character_ServerMovePacked_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.packedbits_){}
    , decltype(_impl_.bitsnum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.packedbits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packedbits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_packedbits().empty()) {
    _this->_impl_.packedbits_.Set(from._internal_packedbits(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.bitsnum_ = from._impl_.bitsnum_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.Character_ServerMovePacked_Params)
}

inline void Character_ServerMovePacked_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.packedbits_){}
    , decltype(_impl_.bitsnum_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.packedbits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packedbits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Character_ServerMovePacked_Params::~Character_ServerMovePacked_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.Character_ServerMovePacked_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Character_ServerMovePacked_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.packedbits_.Destroy();
}

void Character_ServerMovePacked_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Character_ServerMovePacked_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.Character_ServerMovePacked_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.packedbits_.ClearToEmpty();
  _impl_.bitsnum_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Character_ServerMovePacked_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 bitsNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.bitsnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes packedBits = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_packedbits();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Character_ServerMovePacked_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.Character_ServerMovePacked_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 bitsNum = 1;
  if (this->_internal_bitsnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_bitsnum(), target);
  }

  // bytes packedBits = 2;
  if (!this->_internal_packedbits().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_packedbits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.Character_ServerMovePacked_Params)
  return target;
}

size_t Character_ServerMovePacked_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.Character_ServerMovePacked_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes packedBits = 2;
  if (!this->_internal_packedbits().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_packedbits());
  }

  // uint32 bitsNum = 1;
  if (this->_internal_bitsnum() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitsnum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Character_ServerMovePacked_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Character_ServerMovePacked_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Character_ServerMovePacked_Params::GetClassData() const { return &_class_data_; }


void Character_ServerMovePacked_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Character_ServerMovePacked_Params*>(&to_msg);
  auto& from = static_cast<const Character_ServerMovePacked_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.Character_ServerMovePacked_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_packedbits().empty()) {
    _this->_internal_set_packedbits(from._internal_packedbits());
  }
  if (from._internal_bitsnum() != 0) {
    _this->_internal_set_bitsnum(from._internal_bitsnum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Character_ServerMovePacked_Params::CopyFrom(const Character_ServerMovePacked_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.Character_ServerMovePacked_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Character_ServerMovePacked_Params::IsInitialized() const {
  return true;
}

void Character_ServerMovePacked_Params::InternalSwap(Character_ServerMovePacked_Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.packedbits_, lhs_arena,
      &other->_impl_.packedbits_, rhs_arena
  );
  swap(_impl_.bitsnum_, other->_impl_.bitsnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Character_ServerMovePacked_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[27]);
}

// ===================================================================

class Character_ClientMoveResponsePacked_Params::_Internal {
 public:
};

Character_ClientMoveResponsePacked_Params::Character_ClientMoveResponsePacked_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.Character_ClientMoveResponsePacked_Params)
}
Character_ClientMoveResponsePacked_Params::Character_ClientMoveResponsePacked_Params(const Character_ClientMoveResponsePacked_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Character_ClientMoveResponsePacked_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.packedbits_){}
    , decltype(_impl_.bitsnum_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.packedbits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packedbits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_packedbits().empty()) {
    _this->_impl_.packedbits_.Set(from._internal_packedbits(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.bitsnum_ = from._impl_.bitsnum_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.Character_ClientMoveResponsePacked_Params)
}

inline void Character_ClientMoveResponsePacked_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.packedbits_){}
    , decltype(_impl_.bitsnum_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.packedbits_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packedbits_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Character_ClientMoveResponsePacked_Params::~Character_ClientMoveResponsePacked_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.Character_ClientMoveResponsePacked_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Character_ClientMoveResponsePacked_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.packedbits_.Destroy();
}

void Character_ClientMoveResponsePacked_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Character_ClientMoveResponsePacked_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.Character_ClientMoveResponsePacked_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.packedbits_.ClearToEmpty();
  _impl_.bitsnum_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Character_ClientMoveResponsePacked_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 bitsNum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.bitsnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes packedBits = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_packedbits();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Character_ClientMoveResponsePacked_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.Character_ClientMoveResponsePacked_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 bitsNum = 1;
  if (this->_internal_bitsnum() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_bitsnum(), target);
  }

  // bytes packedBits = 2;
  if (!this->_internal_packedbits().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_packedbits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.Character_ClientMoveResponsePacked_Params)
  return target;
}

size_t Character_ClientMoveResponsePacked_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.Character_ClientMoveResponsePacked_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes packedBits = 2;
  if (!this->_internal_packedbits().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_packedbits());
  }

  // uint32 bitsNum = 1;
  if (this->_internal_bitsnum() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bitsnum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Character_ClientMoveResponsePacked_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Character_ClientMoveResponsePacked_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Character_ClientMoveResponsePacked_Params::GetClassData() const { return &_class_data_; }


void Character_ClientMoveResponsePacked_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Character_ClientMoveResponsePacked_Params*>(&to_msg);
  auto& from = static_cast<const Character_ClientMoveResponsePacked_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.Character_ClientMoveResponsePacked_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_packedbits().empty()) {
    _this->_internal_set_packedbits(from._internal_packedbits());
  }
  if (from._internal_bitsnum() != 0) {
    _this->_internal_set_bitsnum(from._internal_bitsnum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Character_ClientMoveResponsePacked_Params::CopyFrom(const Character_ClientMoveResponsePacked_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.Character_ClientMoveResponsePacked_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Character_ClientMoveResponsePacked_Params::IsInitialized() const {
  return true;
}

void Character_ClientMoveResponsePacked_Params::InternalSwap(Character_ClientMoveResponsePacked_Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.packedbits_, lhs_arena,
      &other->_impl_.packedbits_, rhs_arena
  );
  swap(_impl_.bitsnum_, other->_impl_.bitsnum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Character_ClientMoveResponsePacked_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[28]);
}

// ===================================================================

class PlayerState::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerState>()._impl_._has_bits_);
  static void set_has_score(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_playerid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ping(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_playername(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PlayerState::PlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerState)
}
PlayerState::PlayerState(const PlayerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playername_){}
    , decltype(_impl_.score_){}
    , decltype(_impl_.playerid_){}
    , decltype(_impl_.ping_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.playername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.playername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_playername()) {
    _this->_impl_.playername_.Set(from._internal_playername(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.score_, &from._impl_.score_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ping_) -
    reinterpret_cast<char*>(&_impl_.score_)) + sizeof(_impl_.ping_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerState)
}

inline void PlayerState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playername_){}
    , decltype(_impl_.score_){0}
    , decltype(_impl_.playerid_){0}
    , decltype(_impl_.ping_){0u}
  };
  _impl_.playername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.playername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerState::~PlayerState() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.playername_.Destroy();
}

void PlayerState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.playername_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.score_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ping_) -
        reinterpret_cast<char*>(&_impl_.score_)) + sizeof(_impl_.ping_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float score = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_score(&has_bits);
          _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 playerId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_playerid(&has_bits);
          _impl_.playerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ping = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ping(&has_bits);
          _impl_.ping_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string playerName = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_playername();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.PlayerState.playerName"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float score = 2;
  if (_internal_has_score()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_score(), target);
  }

  // optional int32 playerId = 3;
  if (_internal_has_playerid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_playerid(), target);
  }

  // optional uint32 ping = 4;
  if (_internal_has_ping()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ping(), target);
  }

  // optional string playerName = 5;
  if (_internal_has_playername()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_playername().data(), static_cast<int>(this->_internal_playername().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.PlayerState.playerName");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_playername(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerState)
  return target;
}

size_t PlayerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string playerName = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_playername());
    }

    // optional float score = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional int32 playerId = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_playerid());
    }

    // optional uint32 ping = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ping());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerState::GetClassData() const { return &_class_data_; }


void PlayerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerState*>(&to_msg);
  auto& from = static_cast<const PlayerState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_playername(from._internal_playername());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.score_ = from._impl_.score_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.playerid_ = from._impl_.playerid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ping_ = from._impl_.ping_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerState::CopyFrom(const PlayerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerState::IsInitialized() const {
  return true;
}

void PlayerState::InternalSwap(PlayerState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.playername_, lhs_arena,
      &other->_impl_.playername_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerState, _impl_.ping_)
      + sizeof(PlayerState::_impl_.ping_)
      - PROTOBUF_FIELD_OFFSET(PlayerState, _impl_.score_)>(
          reinterpret_cast<char*>(&_impl_.score_),
          reinterpret_cast<char*>(&other->_impl_.score_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[29]);
}

// ===================================================================

class ControllerState::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& playerstate(const ControllerState* msg);
  static const ::unrealpb::UnrealObjectRef& pawn(const ControllerState* msg);
};

const ::unrealpb::UnrealObjectRef&
ControllerState::_Internal::playerstate(const ControllerState* msg) {
  return *msg->_impl_.playerstate_;
}
const ::unrealpb::UnrealObjectRef&
ControllerState::_Internal::pawn(const ControllerState* msg) {
  return *msg->_impl_.pawn_;
}
ControllerState::ControllerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.ControllerState)
}
ControllerState::ControllerState(const ControllerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ControllerState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.playerstate_){nullptr}
    , decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_playerstate()) {
    _this->_impl_.playerstate_ = new ::unrealpb::UnrealObjectRef(*from._impl_.playerstate_);
  }
  if (from._internal_has_pawn()) {
    _this->_impl_.pawn_ = new ::unrealpb::UnrealObjectRef(*from._impl_.pawn_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.ControllerState)
}

inline void ControllerState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.playerstate_){nullptr}
    , decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ControllerState::~ControllerState() {
  // @@protoc_insertion_point(destructor:unrealpb.ControllerState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ControllerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.playerstate_;
  if (this != internal_default_instance()) delete _impl_.pawn_;
}

void ControllerState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ControllerState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.ControllerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.playerstate_ != nullptr) {
    delete _impl_.playerstate_;
  }
  _impl_.playerstate_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pawn_ != nullptr) {
    delete _impl_.pawn_;
  }
  _impl_.pawn_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControllerState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef playerState = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_playerstate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.UnrealObjectRef pawn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pawn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ControllerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.ControllerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef playerState = 2;
  if (this->_internal_has_playerstate()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::playerstate(this),
        _Internal::playerstate(this).GetCachedSize(), target, stream);
  }

  // .unrealpb.UnrealObjectRef pawn = 3;
  if (this->_internal_has_pawn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pawn(this),
        _Internal::pawn(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.ControllerState)
  return target;
}

size_t ControllerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.ControllerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef playerState = 2;
  if (this->_internal_has_playerstate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.playerstate_);
  }

  // .unrealpb.UnrealObjectRef pawn = 3;
  if (this->_internal_has_pawn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pawn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ControllerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ControllerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ControllerState::GetClassData() const { return &_class_data_; }


void ControllerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ControllerState*>(&to_msg);
  auto& from = static_cast<const ControllerState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.ControllerState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_playerstate()) {
    _this->_internal_mutable_playerstate()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_playerstate());
  }
  if (from._internal_has_pawn()) {
    _this->_internal_mutable_pawn()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_pawn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ControllerState::CopyFrom(const ControllerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.ControllerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControllerState::IsInitialized() const {
  return true;
}

void ControllerState::InternalSwap(ControllerState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ControllerState, _impl_.pawn_)
      + sizeof(ControllerState::_impl_.pawn_)
      - PROTOBUF_FIELD_OFFSET(ControllerState, _impl_.playerstate_)>(
          reinterpret_cast<char*>(&_impl_.playerstate_),
          reinterpret_cast<char*>(&other->_impl_.playerstate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ControllerState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[30]);
}

// ===================================================================

class Controller_ClientSetLocation_Params::_Internal {
 public:
  static const ::unrealpb::FVector& newlocation(const Controller_ClientSetLocation_Params* msg);
  static const ::unrealpb::FVector& newrotation(const Controller_ClientSetLocation_Params* msg);
};

const ::unrealpb::FVector&
Controller_ClientSetLocation_Params::_Internal::newlocation(const Controller_ClientSetLocation_Params* msg) {
  return *msg->_impl_.newlocation_;
}
const ::unrealpb::FVector&
Controller_ClientSetLocation_Params::_Internal::newrotation(const Controller_ClientSetLocation_Params* msg) {
  return *msg->_impl_.newrotation_;
}
Controller_ClientSetLocation_Params::Controller_ClientSetLocation_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.Controller_ClientSetLocation_Params)
}
Controller_ClientSetLocation_Params::Controller_ClientSetLocation_Params(const Controller_ClientSetLocation_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Controller_ClientSetLocation_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.newlocation_){nullptr}
    , decltype(_impl_.newrotation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_newlocation()) {
    _this->_impl_.newlocation_ = new ::unrealpb::FVector(*from._impl_.newlocation_);
  }
  if (from._internal_has_newrotation()) {
    _this->_impl_.newrotation_ = new ::unrealpb::FVector(*from._impl_.newrotation_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.Controller_ClientSetLocation_Params)
}

inline void Controller_ClientSetLocation_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.newlocation_){nullptr}
    , decltype(_impl_.newrotation_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Controller_ClientSetLocation_Params::~Controller_ClientSetLocation_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.Controller_ClientSetLocation_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Controller_ClientSetLocation_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.newlocation_;
  if (this != internal_default_instance()) delete _impl_.newrotation_;
}

void Controller_ClientSetLocation_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Controller_ClientSetLocation_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.Controller_ClientSetLocation_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.newlocation_ != nullptr) {
    delete _impl_.newlocation_;
  }
  _impl_.newlocation_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.newrotation_ != nullptr) {
    delete _impl_.newrotation_;
  }
  _impl_.newrotation_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Controller_ClientSetLocation_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.FVector newLocation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_newlocation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.FVector newRotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_newrotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Controller_ClientSetLocation_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.Controller_ClientSetLocation_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.FVector newLocation = 1;
  if (this->_internal_has_newlocation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::newlocation(this),
        _Internal::newlocation(this).GetCachedSize(), target, stream);
  }

  // .unrealpb.FVector newRotation = 2;
  if (this->_internal_has_newrotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::newrotation(this),
        _Internal::newrotation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.Controller_ClientSetLocation_Params)
  return target;
}

size_t Controller_ClientSetLocation_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.Controller_ClientSetLocation_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.FVector newLocation = 1;
  if (this->_internal_has_newlocation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newlocation_);
  }

  // .unrealpb.FVector newRotation = 2;
  if (this->_internal_has_newrotation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newrotation_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Controller_ClientSetLocation_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Controller_ClientSetLocation_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Controller_ClientSetLocation_Params::GetClassData() const { return &_class_data_; }


void Controller_ClientSetLocation_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Controller_ClientSetLocation_Params*>(&to_msg);
  auto& from = static_cast<const Controller_ClientSetLocation_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.Controller_ClientSetLocation_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_newlocation()) {
    _this->_internal_mutable_newlocation()->::unrealpb::FVector::MergeFrom(
        from._internal_newlocation());
  }
  if (from._internal_has_newrotation()) {
    _this->_internal_mutable_newrotation()->::unrealpb::FVector::MergeFrom(
        from._internal_newrotation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Controller_ClientSetLocation_Params::CopyFrom(const Controller_ClientSetLocation_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.Controller_ClientSetLocation_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Controller_ClientSetLocation_Params::IsInitialized() const {
  return true;
}

void Controller_ClientSetLocation_Params::InternalSwap(Controller_ClientSetLocation_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Controller_ClientSetLocation_Params, _impl_.newrotation_)
      + sizeof(Controller_ClientSetLocation_Params::_impl_.newrotation_)
      - PROTOBUF_FIELD_OFFSET(Controller_ClientSetLocation_Params, _impl_.newlocation_)>(
          reinterpret_cast<char*>(&_impl_.newlocation_),
          reinterpret_cast<char*>(&other->_impl_.newlocation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Controller_ClientSetLocation_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[31]);
}

// ===================================================================

class Controller_ClientSetRotation_Params::_Internal {
 public:
  static const ::unrealpb::FVector& newrotation(const Controller_ClientSetRotation_Params* msg);
};

const ::unrealpb::FVector&
Controller_ClientSetRotation_Params::_Internal::newrotation(const Controller_ClientSetRotation_Params* msg) {
  return *msg->_impl_.newrotation_;
}
Controller_ClientSetRotation_Params::Controller_ClientSetRotation_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.Controller_ClientSetRotation_Params)
}
Controller_ClientSetRotation_Params::Controller_ClientSetRotation_Params(const Controller_ClientSetRotation_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Controller_ClientSetRotation_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.newrotation_){nullptr}
    , decltype(_impl_.bresetcamera_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_newrotation()) {
    _this->_impl_.newrotation_ = new ::unrealpb::FVector(*from._impl_.newrotation_);
  }
  _this->_impl_.bresetcamera_ = from._impl_.bresetcamera_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.Controller_ClientSetRotation_Params)
}

inline void Controller_ClientSetRotation_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.newrotation_){nullptr}
    , decltype(_impl_.bresetcamera_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Controller_ClientSetRotation_Params::~Controller_ClientSetRotation_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.Controller_ClientSetRotation_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Controller_ClientSetRotation_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.newrotation_;
}

void Controller_ClientSetRotation_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Controller_ClientSetRotation_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.Controller_ClientSetRotation_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.newrotation_ != nullptr) {
    delete _impl_.newrotation_;
  }
  _impl_.newrotation_ = nullptr;
  _impl_.bresetcamera_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Controller_ClientSetRotation_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.FVector newRotation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_newrotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bResetCamera = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.bresetcamera_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Controller_ClientSetRotation_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.Controller_ClientSetRotation_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.FVector newRotation = 1;
  if (this->_internal_has_newrotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::newrotation(this),
        _Internal::newrotation(this).GetCachedSize(), target, stream);
  }

  // bool bResetCamera = 2;
  if (this->_internal_bresetcamera() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_bresetcamera(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.Controller_ClientSetRotation_Params)
  return target;
}

size_t Controller_ClientSetRotation_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.Controller_ClientSetRotation_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.FVector newRotation = 1;
  if (this->_internal_has_newrotation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newrotation_);
  }

  // bool bResetCamera = 2;
  if (this->_internal_bresetcamera() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Controller_ClientSetRotation_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Controller_ClientSetRotation_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Controller_ClientSetRotation_Params::GetClassData() const { return &_class_data_; }


void Controller_ClientSetRotation_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Controller_ClientSetRotation_Params*>(&to_msg);
  auto& from = static_cast<const Controller_ClientSetRotation_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.Controller_ClientSetRotation_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_newrotation()) {
    _this->_internal_mutable_newrotation()->::unrealpb::FVector::MergeFrom(
        from._internal_newrotation());
  }
  if (from._internal_bresetcamera() != 0) {
    _this->_internal_set_bresetcamera(from._internal_bresetcamera());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Controller_ClientSetRotation_Params::CopyFrom(const Controller_ClientSetRotation_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.Controller_ClientSetRotation_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Controller_ClientSetRotation_Params::IsInitialized() const {
  return true;
}

void Controller_ClientSetRotation_Params::InternalSwap(Controller_ClientSetRotation_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Controller_ClientSetRotation_Params, _impl_.bresetcamera_)
      + sizeof(Controller_ClientSetRotation_Params::_impl_.bresetcamera_)
      - PROTOBUF_FIELD_OFFSET(Controller_ClientSetRotation_Params, _impl_.newrotation_)>(
          reinterpret_cast<char*>(&_impl_.newrotation_),
          reinterpret_cast<char*>(&other->_impl_.newrotation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Controller_ClientSetRotation_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[32]);
}

// ===================================================================

class PlayerControllerState::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerControllerState>()._impl_._has_bits_);
  static const ::unrealpb::FVector& targetviewrotation(const PlayerControllerState* msg);
  static void set_has_targetviewrotation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::unrealpb::FVector& spawnlocation(const PlayerControllerState* msg);
  static void set_has_spawnlocation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::unrealpb::FVector&
PlayerControllerState::_Internal::targetviewrotation(const PlayerControllerState* msg) {
  return *msg->_impl_.targetviewrotation_;
}
const ::unrealpb::FVector&
PlayerControllerState::_Internal::spawnlocation(const PlayerControllerState* msg) {
  return *msg->_impl_.spawnlocation_;
}
PlayerControllerState::PlayerControllerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerControllerState)
}
PlayerControllerState::PlayerControllerState(const PlayerControllerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerControllerState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetviewrotation_){nullptr}
    , decltype(_impl_.spawnlocation_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_targetviewrotation()) {
    _this->_impl_.targetviewrotation_ = new ::unrealpb::FVector(*from._impl_.targetviewrotation_);
  }
  if (from._internal_has_spawnlocation()) {
    _this->_impl_.spawnlocation_ = new ::unrealpb::FVector(*from._impl_.spawnlocation_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerControllerState)
}

inline void PlayerControllerState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.targetviewrotation_){nullptr}
    , decltype(_impl_.spawnlocation_){nullptr}
  };
}

PlayerControllerState::~PlayerControllerState() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerControllerState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerControllerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.targetviewrotation_;
  if (this != internal_default_instance()) delete _impl_.spawnlocation_;
}

void PlayerControllerState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerControllerState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerControllerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.targetviewrotation_ != nullptr);
      _impl_.targetviewrotation_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.spawnlocation_ != nullptr);
      _impl_.spawnlocation_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerControllerState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .unrealpb.FVector targetViewRotation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_targetviewrotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector spawnLocation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_spawnlocation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerControllerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerControllerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .unrealpb.FVector targetViewRotation = 2;
  if (_internal_has_targetviewrotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::targetviewrotation(this),
        _Internal::targetviewrotation(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector spawnLocation = 3;
  if (_internal_has_spawnlocation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::spawnlocation(this),
        _Internal::spawnlocation(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerControllerState)
  return target;
}

size_t PlayerControllerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerControllerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .unrealpb.FVector targetViewRotation = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.targetviewrotation_);
    }

    // optional .unrealpb.FVector spawnLocation = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.spawnlocation_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerControllerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerControllerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerControllerState::GetClassData() const { return &_class_data_; }


void PlayerControllerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerControllerState*>(&to_msg);
  auto& from = static_cast<const PlayerControllerState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerControllerState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_targetviewrotation()->::unrealpb::FVector::MergeFrom(
          from._internal_targetviewrotation());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_spawnlocation()->::unrealpb::FVector::MergeFrom(
          from._internal_spawnlocation());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerControllerState::CopyFrom(const PlayerControllerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerControllerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerControllerState::IsInitialized() const {
  return true;
}

void PlayerControllerState::InternalSwap(PlayerControllerState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerControllerState, _impl_.spawnlocation_)
      + sizeof(PlayerControllerState::_impl_.spawnlocation_)
      - PROTOBUF_FIELD_OFFSET(PlayerControllerState, _impl_.targetviewrotation_)>(
          reinterpret_cast<char*>(&_impl_.targetviewrotation_),
          reinterpret_cast<char*>(&other->_impl_.targetviewrotation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerControllerState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[33]);
}

// ===================================================================

class PlayerController_ServerUpdateCamera_Params::_Internal {
 public:
  static const ::unrealpb::FVector& camloc(const PlayerController_ServerUpdateCamera_Params* msg);
};

const ::unrealpb::FVector&
PlayerController_ServerUpdateCamera_Params::_Internal::camloc(const PlayerController_ServerUpdateCamera_Params* msg) {
  return *msg->_impl_.camloc_;
}
PlayerController_ServerUpdateCamera_Params::PlayerController_ServerUpdateCamera_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ServerUpdateCamera_Params)
}
PlayerController_ServerUpdateCamera_Params::PlayerController_ServerUpdateCamera_Params(const PlayerController_ServerUpdateCamera_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ServerUpdateCamera_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.camloc_){nullptr}
    , decltype(_impl_.campitchandyaw_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_camloc()) {
    _this->_impl_.camloc_ = new ::unrealpb::FVector(*from._impl_.camloc_);
  }
  _this->_impl_.campitchandyaw_ = from._impl_.campitchandyaw_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ServerUpdateCamera_Params)
}

inline void PlayerController_ServerUpdateCamera_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.camloc_){nullptr}
    , decltype(_impl_.campitchandyaw_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ServerUpdateCamera_Params::~PlayerController_ServerUpdateCamera_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ServerUpdateCamera_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ServerUpdateCamera_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.camloc_;
}

void PlayerController_ServerUpdateCamera_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ServerUpdateCamera_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ServerUpdateCamera_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.camloc_ != nullptr) {
    delete _impl_.camloc_;
  }
  _impl_.camloc_ = nullptr;
  _impl_.campitchandyaw_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ServerUpdateCamera_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.FVector camLoc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_camloc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 camPitchAndYaw = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.campitchandyaw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ServerUpdateCamera_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ServerUpdateCamera_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.FVector camLoc = 1;
  if (this->_internal_has_camloc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::camloc(this),
        _Internal::camloc(this).GetCachedSize(), target, stream);
  }

  // int32 camPitchAndYaw = 2;
  if (this->_internal_campitchandyaw() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_campitchandyaw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ServerUpdateCamera_Params)
  return target;
}

size_t PlayerController_ServerUpdateCamera_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ServerUpdateCamera_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.FVector camLoc = 1;
  if (this->_internal_has_camloc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.camloc_);
  }

  // int32 camPitchAndYaw = 2;
  if (this->_internal_campitchandyaw() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_campitchandyaw());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ServerUpdateCamera_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ServerUpdateCamera_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ServerUpdateCamera_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ServerUpdateCamera_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ServerUpdateCamera_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ServerUpdateCamera_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ServerUpdateCamera_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_camloc()) {
    _this->_internal_mutable_camloc()->::unrealpb::FVector::MergeFrom(
        from._internal_camloc());
  }
  if (from._internal_campitchandyaw() != 0) {
    _this->_internal_set_campitchandyaw(from._internal_campitchandyaw());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ServerUpdateCamera_Params::CopyFrom(const PlayerController_ServerUpdateCamera_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ServerUpdateCamera_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ServerUpdateCamera_Params::IsInitialized() const {
  return true;
}

void PlayerController_ServerUpdateCamera_Params::InternalSwap(PlayerController_ServerUpdateCamera_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerController_ServerUpdateCamera_Params, _impl_.campitchandyaw_)
      + sizeof(PlayerController_ServerUpdateCamera_Params::_impl_.campitchandyaw_)
      - PROTOBUF_FIELD_OFFSET(PlayerController_ServerUpdateCamera_Params, _impl_.camloc_)>(
          reinterpret_cast<char*>(&_impl_.camloc_),
          reinterpret_cast<char*>(&other->_impl_.camloc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ServerUpdateCamera_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[34]);
}

// ===================================================================

class PlayerController_ClientSetHUD_Params::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerController_ClientSetHUD_Params>()._impl_._has_bits_);
  static void set_has_hudclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PlayerController_ClientSetHUD_Params::PlayerController_ClientSetHUD_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientSetHUD_Params)
}
PlayerController_ClientSetHUD_Params::PlayerController_ClientSetHUD_Params(const PlayerController_ClientSetHUD_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientSetHUD_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hudclassname_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hudclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hudclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hudclassname()) {
    _this->_impl_.hudclassname_.Set(from._internal_hudclassname(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientSetHUD_Params)
}

inline void PlayerController_ClientSetHUD_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hudclassname_){}
  };
  _impl_.hudclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hudclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerController_ClientSetHUD_Params::~PlayerController_ClientSetHUD_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientSetHUD_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientSetHUD_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hudclassname_.Destroy();
}

void PlayerController_ClientSetHUD_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientSetHUD_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientSetHUD_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.hudclassname_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientSetHUD_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string hudClassName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hudclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.PlayerController_ClientSetHUD_Params.hudClassName"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientSetHUD_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientSetHUD_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string hudClassName = 1;
  if (_internal_has_hudclassname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hudclassname().data(), static_cast<int>(this->_internal_hudclassname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.PlayerController_ClientSetHUD_Params.hudClassName");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hudclassname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientSetHUD_Params)
  return target;
}

size_t PlayerController_ClientSetHUD_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientSetHUD_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string hudClassName = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hudclassname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientSetHUD_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientSetHUD_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientSetHUD_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientSetHUD_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientSetHUD_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientSetHUD_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientSetHUD_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hudclassname()) {
    _this->_internal_set_hudclassname(from._internal_hudclassname());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientSetHUD_Params::CopyFrom(const PlayerController_ClientSetHUD_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientSetHUD_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientSetHUD_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientSetHUD_Params::InternalSwap(PlayerController_ClientSetHUD_Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hudclassname_, lhs_arena,
      &other->_impl_.hudclassname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientSetHUD_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[35]);
}

// ===================================================================

class PlayerController_ClientSetViewTarget_Params::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& actor(const PlayerController_ClientSetViewTarget_Params* msg);
};

const ::unrealpb::UnrealObjectRef&
PlayerController_ClientSetViewTarget_Params::_Internal::actor(const PlayerController_ClientSetViewTarget_Params* msg) {
  return *msg->_impl_.actor_;
}
PlayerController_ClientSetViewTarget_Params::PlayerController_ClientSetViewTarget_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientSetViewTarget_Params)
}
PlayerController_ClientSetViewTarget_Params::PlayerController_ClientSetViewTarget_Params(const PlayerController_ClientSetViewTarget_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientSetViewTarget_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.actor_){nullptr}
    , decltype(_impl_.blendtime_){}
    , decltype(_impl_.blendfunction_){}
    , decltype(_impl_.blendexp_){}
    , decltype(_impl_.blockoutgoing_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_actor()) {
    _this->_impl_.actor_ = new ::unrealpb::UnrealObjectRef(*from._impl_.actor_);
  }
  ::memcpy(&_impl_.blendtime_, &from._impl_.blendtime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blockoutgoing_) -
    reinterpret_cast<char*>(&_impl_.blendtime_)) + sizeof(_impl_.blockoutgoing_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientSetViewTarget_Params)
}

inline void PlayerController_ClientSetViewTarget_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.actor_){nullptr}
    , decltype(_impl_.blendtime_){0}
    , decltype(_impl_.blendfunction_){0u}
    , decltype(_impl_.blendexp_){0}
    , decltype(_impl_.blockoutgoing_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ClientSetViewTarget_Params::~PlayerController_ClientSetViewTarget_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientSetViewTarget_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientSetViewTarget_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.actor_;
}

void PlayerController_ClientSetViewTarget_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientSetViewTarget_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientSetViewTarget_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.actor_ != nullptr) {
    delete _impl_.actor_;
  }
  _impl_.actor_ = nullptr;
  ::memset(&_impl_.blendtime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.blockoutgoing_) -
      reinterpret_cast<char*>(&_impl_.blendtime_)) + sizeof(_impl_.blockoutgoing_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientSetViewTarget_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef actor = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_actor(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float blendTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.blendtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint32 blendFunction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.blendfunction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float blendExp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.blendexp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // bool bLockOutgoing = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.blockoutgoing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientSetViewTarget_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientSetViewTarget_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef actor = 1;
  if (this->_internal_has_actor()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::actor(this),
        _Internal::actor(this).GetCachedSize(), target, stream);
  }

  // float blendTime = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendtime = this->_internal_blendtime();
  uint32_t raw_blendtime;
  memcpy(&raw_blendtime, &tmp_blendtime, sizeof(tmp_blendtime));
  if (raw_blendtime != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_blendtime(), target);
  }

  // uint32 blendFunction = 3;
  if (this->_internal_blendfunction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_blendfunction(), target);
  }

  // float blendExp = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendexp = this->_internal_blendexp();
  uint32_t raw_blendexp;
  memcpy(&raw_blendexp, &tmp_blendexp, sizeof(tmp_blendexp));
  if (raw_blendexp != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_blendexp(), target);
  }

  // bool bLockOutgoing = 5;
  if (this->_internal_blockoutgoing() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_blockoutgoing(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientSetViewTarget_Params)
  return target;
}

size_t PlayerController_ClientSetViewTarget_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientSetViewTarget_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef actor = 1;
  if (this->_internal_has_actor()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.actor_);
  }

  // float blendTime = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendtime = this->_internal_blendtime();
  uint32_t raw_blendtime;
  memcpy(&raw_blendtime, &tmp_blendtime, sizeof(tmp_blendtime));
  if (raw_blendtime != 0) {
    total_size += 1 + 4;
  }

  // uint32 blendFunction = 3;
  if (this->_internal_blendfunction() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_blendfunction());
  }

  // float blendExp = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendexp = this->_internal_blendexp();
  uint32_t raw_blendexp;
  memcpy(&raw_blendexp, &tmp_blendexp, sizeof(tmp_blendexp));
  if (raw_blendexp != 0) {
    total_size += 1 + 4;
  }

  // bool bLockOutgoing = 5;
  if (this->_internal_blockoutgoing() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientSetViewTarget_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientSetViewTarget_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientSetViewTarget_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientSetViewTarget_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientSetViewTarget_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientSetViewTarget_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientSetViewTarget_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_actor()) {
    _this->_internal_mutable_actor()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_actor());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendtime = from._internal_blendtime();
  uint32_t raw_blendtime;
  memcpy(&raw_blendtime, &tmp_blendtime, sizeof(tmp_blendtime));
  if (raw_blendtime != 0) {
    _this->_internal_set_blendtime(from._internal_blendtime());
  }
  if (from._internal_blendfunction() != 0) {
    _this->_internal_set_blendfunction(from._internal_blendfunction());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_blendexp = from._internal_blendexp();
  uint32_t raw_blendexp;
  memcpy(&raw_blendexp, &tmp_blendexp, sizeof(tmp_blendexp));
  if (raw_blendexp != 0) {
    _this->_internal_set_blendexp(from._internal_blendexp());
  }
  if (from._internal_blockoutgoing() != 0) {
    _this->_internal_set_blockoutgoing(from._internal_blockoutgoing());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientSetViewTarget_Params::CopyFrom(const PlayerController_ClientSetViewTarget_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientSetViewTarget_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientSetViewTarget_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientSetViewTarget_Params::InternalSwap(PlayerController_ClientSetViewTarget_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerController_ClientSetViewTarget_Params, _impl_.blockoutgoing_)
      + sizeof(PlayerController_ClientSetViewTarget_Params::_impl_.blockoutgoing_)
      - PROTOBUF_FIELD_OFFSET(PlayerController_ClientSetViewTarget_Params, _impl_.actor_)>(
          reinterpret_cast<char*>(&_impl_.actor_),
          reinterpret_cast<char*>(&other->_impl_.actor_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientSetViewTarget_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[36]);
}

// ===================================================================

class PlayerController_ClientEnableNetworkVoice_Params::_Internal {
 public:
  using HasBits = decltype(std::declval<PlayerController_ClientEnableNetworkVoice_Params>()._impl_._has_bits_);
  static void set_has_benable(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PlayerController_ClientEnableNetworkVoice_Params::PlayerController_ClientEnableNetworkVoice_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
}
PlayerController_ClientEnableNetworkVoice_Params::PlayerController_ClientEnableNetworkVoice_Params(const PlayerController_ClientEnableNetworkVoice_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientEnableNetworkVoice_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.benable_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.benable_ = from._impl_.benable_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
}

inline void PlayerController_ClientEnableNetworkVoice_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.benable_){false}
  };
}

PlayerController_ClientEnableNetworkVoice_Params::~PlayerController_ClientEnableNetworkVoice_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientEnableNetworkVoice_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerController_ClientEnableNetworkVoice_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientEnableNetworkVoice_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.benable_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientEnableNetworkVoice_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool bEnable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_benable(&has_bits);
          _impl_.benable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientEnableNetworkVoice_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool bEnable = 1;
  if (_internal_has_benable()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_benable(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  return target;
}

size_t PlayerController_ClientEnableNetworkVoice_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool bEnable = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientEnableNetworkVoice_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientEnableNetworkVoice_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientEnableNetworkVoice_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientEnableNetworkVoice_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientEnableNetworkVoice_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientEnableNetworkVoice_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_benable()) {
    _this->_internal_set_benable(from._internal_benable());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientEnableNetworkVoice_Params::CopyFrom(const PlayerController_ClientEnableNetworkVoice_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientEnableNetworkVoice_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientEnableNetworkVoice_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientEnableNetworkVoice_Params::InternalSwap(PlayerController_ClientEnableNetworkVoice_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.benable_, other->_impl_.benable_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientEnableNetworkVoice_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[37]);
}

// ===================================================================

class PlayerController_ClientCapBandwidth_Params::_Internal {
 public:
};

PlayerController_ClientCapBandwidth_Params::PlayerController_ClientCapBandwidth_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientCapBandwidth_Params)
}
PlayerController_ClientCapBandwidth_Params::PlayerController_ClientCapBandwidth_Params(const PlayerController_ClientCapBandwidth_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientCapBandwidth_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.cap_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.cap_ = from._impl_.cap_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientCapBandwidth_Params)
}

inline void PlayerController_ClientCapBandwidth_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.cap_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ClientCapBandwidth_Params::~PlayerController_ClientCapBandwidth_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientCapBandwidth_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientCapBandwidth_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PlayerController_ClientCapBandwidth_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientCapBandwidth_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientCapBandwidth_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cap_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientCapBandwidth_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 cap = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.cap_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientCapBandwidth_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientCapBandwidth_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 cap = 1;
  if (this->_internal_cap() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cap(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientCapBandwidth_Params)
  return target;
}

size_t PlayerController_ClientCapBandwidth_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientCapBandwidth_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 cap = 1;
  if (this->_internal_cap() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cap());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientCapBandwidth_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientCapBandwidth_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientCapBandwidth_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientCapBandwidth_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientCapBandwidth_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientCapBandwidth_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientCapBandwidth_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_cap() != 0) {
    _this->_internal_set_cap(from._internal_cap());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientCapBandwidth_Params::CopyFrom(const PlayerController_ClientCapBandwidth_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientCapBandwidth_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientCapBandwidth_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientCapBandwidth_Params::InternalSwap(PlayerController_ClientCapBandwidth_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.cap_, other->_impl_.cap_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientCapBandwidth_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[38]);
}

// ===================================================================

class PlayerController_ClientRestart_Params::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& pawn(const PlayerController_ClientRestart_Params* msg);
};

const ::unrealpb::UnrealObjectRef&
PlayerController_ClientRestart_Params::_Internal::pawn(const PlayerController_ClientRestart_Params* msg) {
  return *msg->_impl_.pawn_;
}
PlayerController_ClientRestart_Params::PlayerController_ClientRestart_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientRestart_Params)
}
PlayerController_ClientRestart_Params::PlayerController_ClientRestart_Params(const PlayerController_ClientRestart_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientRestart_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pawn()) {
    _this->_impl_.pawn_ = new ::unrealpb::UnrealObjectRef(*from._impl_.pawn_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientRestart_Params)
}

inline void PlayerController_ClientRestart_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ClientRestart_Params::~PlayerController_ClientRestart_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientRestart_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientRestart_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pawn_;
}

void PlayerController_ClientRestart_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientRestart_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientRestart_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pawn_ != nullptr) {
    delete _impl_.pawn_;
  }
  _impl_.pawn_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientRestart_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef pawn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pawn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientRestart_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientRestart_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pawn(this),
        _Internal::pawn(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientRestart_Params)
  return target;
}

size_t PlayerController_ClientRestart_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientRestart_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pawn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientRestart_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientRestart_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientRestart_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientRestart_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientRestart_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientRestart_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientRestart_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pawn()) {
    _this->_internal_mutable_pawn()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_pawn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientRestart_Params::CopyFrom(const PlayerController_ClientRestart_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientRestart_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientRestart_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientRestart_Params::InternalSwap(PlayerController_ClientRestart_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.pawn_, other->_impl_.pawn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientRestart_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[39]);
}

// ===================================================================

class PlayerController_ClientSetCameraMode_Params::_Internal {
 public:
};

PlayerController_ClientSetCameraMode_Params::PlayerController_ClientSetCameraMode_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientSetCameraMode_Params)
}
PlayerController_ClientSetCameraMode_Params::PlayerController_ClientSetCameraMode_Params(const PlayerController_ClientSetCameraMode_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientSetCameraMode_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.newcammode_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.newcammode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newcammode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_newcammode().empty()) {
    _this->_impl_.newcammode_.Set(from._internal_newcammode(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientSetCameraMode_Params)
}

inline void PlayerController_ClientSetCameraMode_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.newcammode_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.newcammode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newcammode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerController_ClientSetCameraMode_Params::~PlayerController_ClientSetCameraMode_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientSetCameraMode_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientSetCameraMode_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.newcammode_.Destroy();
}

void PlayerController_ClientSetCameraMode_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientSetCameraMode_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientSetCameraMode_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.newcammode_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientSetCameraMode_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string newCamMode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_newcammode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.PlayerController_ClientSetCameraMode_Params.newCamMode"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientSetCameraMode_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientSetCameraMode_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string newCamMode = 1;
  if (!this->_internal_newcammode().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_newcammode().data(), static_cast<int>(this->_internal_newcammode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.PlayerController_ClientSetCameraMode_Params.newCamMode");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_newcammode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientSetCameraMode_Params)
  return target;
}

size_t PlayerController_ClientSetCameraMode_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientSetCameraMode_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string newCamMode = 1;
  if (!this->_internal_newcammode().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newcammode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientSetCameraMode_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientSetCameraMode_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientSetCameraMode_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientSetCameraMode_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientSetCameraMode_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientSetCameraMode_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientSetCameraMode_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_newcammode().empty()) {
    _this->_internal_set_newcammode(from._internal_newcammode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientSetCameraMode_Params::CopyFrom(const PlayerController_ClientSetCameraMode_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientSetCameraMode_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientSetCameraMode_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientSetCameraMode_Params::InternalSwap(PlayerController_ClientSetCameraMode_Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.newcammode_, lhs_arena,
      &other->_impl_.newcammode_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientSetCameraMode_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[40]);
}

// ===================================================================

class PlayerController_ClientRetryClientRestart_Params::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& pawn(const PlayerController_ClientRetryClientRestart_Params* msg);
};

const ::unrealpb::UnrealObjectRef&
PlayerController_ClientRetryClientRestart_Params::_Internal::pawn(const PlayerController_ClientRetryClientRestart_Params* msg) {
  return *msg->_impl_.pawn_;
}
PlayerController_ClientRetryClientRestart_Params::PlayerController_ClientRetryClientRestart_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientRetryClientRestart_Params)
}
PlayerController_ClientRetryClientRestart_Params::PlayerController_ClientRetryClientRestart_Params(const PlayerController_ClientRetryClientRestart_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientRetryClientRestart_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pawn()) {
    _this->_impl_.pawn_ = new ::unrealpb::UnrealObjectRef(*from._impl_.pawn_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientRetryClientRestart_Params)
}

inline void PlayerController_ClientRetryClientRestart_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ClientRetryClientRestart_Params::~PlayerController_ClientRetryClientRestart_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientRetryClientRestart_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pawn_;
}

void PlayerController_ClientRetryClientRestart_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientRetryClientRestart_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pawn_ != nullptr) {
    delete _impl_.pawn_;
  }
  _impl_.pawn_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientRetryClientRestart_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef pawn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pawn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientRetryClientRestart_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pawn(this),
        _Internal::pawn(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  return target;
}

size_t PlayerController_ClientRetryClientRestart_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pawn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientRetryClientRestart_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientRetryClientRestart_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientRetryClientRestart_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientRetryClientRestart_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientRetryClientRestart_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientRetryClientRestart_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pawn()) {
    _this->_internal_mutable_pawn()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_pawn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientRetryClientRestart_Params::CopyFrom(const PlayerController_ClientRetryClientRestart_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientRetryClientRestart_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientRetryClientRestart_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientRetryClientRestart_Params::InternalSwap(PlayerController_ClientRetryClientRestart_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.pawn_, other->_impl_.pawn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientRetryClientRestart_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[41]);
}

// ===================================================================

class PlayerController_ServerSetSpectatorLocation_Params::_Internal {
 public:
  static const ::unrealpb::FVector& newloc(const PlayerController_ServerSetSpectatorLocation_Params* msg);
  static const ::unrealpb::FVector& newrot(const PlayerController_ServerSetSpectatorLocation_Params* msg);
};

const ::unrealpb::FVector&
PlayerController_ServerSetSpectatorLocation_Params::_Internal::newloc(const PlayerController_ServerSetSpectatorLocation_Params* msg) {
  return *msg->_impl_.newloc_;
}
const ::unrealpb::FVector&
PlayerController_ServerSetSpectatorLocation_Params::_Internal::newrot(const PlayerController_ServerSetSpectatorLocation_Params* msg) {
  return *msg->_impl_.newrot_;
}
PlayerController_ServerSetSpectatorLocation_Params::PlayerController_ServerSetSpectatorLocation_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
}
PlayerController_ServerSetSpectatorLocation_Params::PlayerController_ServerSetSpectatorLocation_Params(const PlayerController_ServerSetSpectatorLocation_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ServerSetSpectatorLocation_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.newloc_){nullptr}
    , decltype(_impl_.newrot_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_newloc()) {
    _this->_impl_.newloc_ = new ::unrealpb::FVector(*from._impl_.newloc_);
  }
  if (from._internal_has_newrot()) {
    _this->_impl_.newrot_ = new ::unrealpb::FVector(*from._impl_.newrot_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
}

inline void PlayerController_ServerSetSpectatorLocation_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.newloc_){nullptr}
    , decltype(_impl_.newrot_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ServerSetSpectatorLocation_Params::~PlayerController_ServerSetSpectatorLocation_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ServerSetSpectatorLocation_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.newloc_;
  if (this != internal_default_instance()) delete _impl_.newrot_;
}

void PlayerController_ServerSetSpectatorLocation_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ServerSetSpectatorLocation_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.newloc_ != nullptr) {
    delete _impl_.newloc_;
  }
  _impl_.newloc_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.newrot_ != nullptr) {
    delete _impl_.newrot_;
  }
  _impl_.newrot_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ServerSetSpectatorLocation_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.FVector newLoc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_newloc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.FVector newRot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_newrot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ServerSetSpectatorLocation_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.FVector newLoc = 1;
  if (this->_internal_has_newloc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::newloc(this),
        _Internal::newloc(this).GetCachedSize(), target, stream);
  }

  // .unrealpb.FVector newRot = 2;
  if (this->_internal_has_newrot()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::newrot(this),
        _Internal::newrot(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  return target;
}

size_t PlayerController_ServerSetSpectatorLocation_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.FVector newLoc = 1;
  if (this->_internal_has_newloc()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newloc_);
  }

  // .unrealpb.FVector newRot = 2;
  if (this->_internal_has_newrot()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.newrot_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ServerSetSpectatorLocation_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ServerSetSpectatorLocation_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ServerSetSpectatorLocation_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ServerSetSpectatorLocation_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ServerSetSpectatorLocation_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ServerSetSpectatorLocation_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_newloc()) {
    _this->_internal_mutable_newloc()->::unrealpb::FVector::MergeFrom(
        from._internal_newloc());
  }
  if (from._internal_has_newrot()) {
    _this->_internal_mutable_newrot()->::unrealpb::FVector::MergeFrom(
        from._internal_newrot());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ServerSetSpectatorLocation_Params::CopyFrom(const PlayerController_ServerSetSpectatorLocation_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ServerSetSpectatorLocation_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ServerSetSpectatorLocation_Params::IsInitialized() const {
  return true;
}

void PlayerController_ServerSetSpectatorLocation_Params::InternalSwap(PlayerController_ServerSetSpectatorLocation_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerController_ServerSetSpectatorLocation_Params, _impl_.newrot_)
      + sizeof(PlayerController_ServerSetSpectatorLocation_Params::_impl_.newrot_)
      - PROTOBUF_FIELD_OFFSET(PlayerController_ServerSetSpectatorLocation_Params, _impl_.newloc_)>(
          reinterpret_cast<char*>(&_impl_.newloc_),
          reinterpret_cast<char*>(&other->_impl_.newloc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ServerSetSpectatorLocation_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[42]);
}

// ===================================================================

class PlayerController_ServerAcknowledgePossession_Params::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& pawn(const PlayerController_ServerAcknowledgePossession_Params* msg);
};

const ::unrealpb::UnrealObjectRef&
PlayerController_ServerAcknowledgePossession_Params::_Internal::pawn(const PlayerController_ServerAcknowledgePossession_Params* msg) {
  return *msg->_impl_.pawn_;
}
PlayerController_ServerAcknowledgePossession_Params::PlayerController_ServerAcknowledgePossession_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
}
PlayerController_ServerAcknowledgePossession_Params::PlayerController_ServerAcknowledgePossession_Params(const PlayerController_ServerAcknowledgePossession_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ServerAcknowledgePossession_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pawn()) {
    _this->_impl_.pawn_ = new ::unrealpb::UnrealObjectRef(*from._impl_.pawn_);
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
}

inline void PlayerController_ServerAcknowledgePossession_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pawn_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlayerController_ServerAcknowledgePossession_Params::~PlayerController_ServerAcknowledgePossession_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ServerAcknowledgePossession_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pawn_;
}

void PlayerController_ServerAcknowledgePossession_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ServerAcknowledgePossession_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.pawn_ != nullptr) {
    delete _impl_.pawn_;
  }
  _impl_.pawn_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ServerAcknowledgePossession_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef pawn = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pawn(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ServerAcknowledgePossession_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pawn(this),
        _Internal::pawn(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  return target;
}

size_t PlayerController_ServerAcknowledgePossession_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef pawn = 1;
  if (this->_internal_has_pawn()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pawn_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ServerAcknowledgePossession_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ServerAcknowledgePossession_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ServerAcknowledgePossession_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ServerAcknowledgePossession_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ServerAcknowledgePossession_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ServerAcknowledgePossession_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pawn()) {
    _this->_internal_mutable_pawn()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_pawn());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ServerAcknowledgePossession_Params::CopyFrom(const PlayerController_ServerAcknowledgePossession_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ServerAcknowledgePossession_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ServerAcknowledgePossession_Params::IsInitialized() const {
  return true;
}

void PlayerController_ServerAcknowledgePossession_Params::InternalSwap(PlayerController_ServerAcknowledgePossession_Params* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.pawn_, other->_impl_.pawn_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ServerAcknowledgePossession_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[43]);
}

// ===================================================================

class PlayerController_ClientGotoState_Params::_Internal {
 public:
};

PlayerController_ClientGotoState_Params::PlayerController_ClientGotoState_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientGotoState_Params)
}
PlayerController_ClientGotoState_Params::PlayerController_ClientGotoState_Params(const PlayerController_ClientGotoState_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientGotoState_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.newstate_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.newstate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newstate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_newstate().empty()) {
    _this->_impl_.newstate_.Set(from._internal_newstate(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientGotoState_Params)
}

inline void PlayerController_ClientGotoState_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.newstate_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.newstate_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newstate_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerController_ClientGotoState_Params::~PlayerController_ClientGotoState_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientGotoState_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientGotoState_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.newstate_.Destroy();
}

void PlayerController_ClientGotoState_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientGotoState_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientGotoState_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.newstate_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientGotoState_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string newState = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_newstate();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.PlayerController_ClientGotoState_Params.newState"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientGotoState_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientGotoState_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string newState = 1;
  if (!this->_internal_newstate().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_newstate().data(), static_cast<int>(this->_internal_newstate().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.PlayerController_ClientGotoState_Params.newState");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_newstate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientGotoState_Params)
  return target;
}

size_t PlayerController_ClientGotoState_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientGotoState_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string newState = 1;
  if (!this->_internal_newstate().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_newstate());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientGotoState_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientGotoState_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientGotoState_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientGotoState_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientGotoState_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientGotoState_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientGotoState_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_newstate().empty()) {
    _this->_internal_set_newstate(from._internal_newstate());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientGotoState_Params::CopyFrom(const PlayerController_ClientGotoState_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientGotoState_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientGotoState_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientGotoState_Params::InternalSwap(PlayerController_ClientGotoState_Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.newstate_, lhs_arena,
      &other->_impl_.newstate_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientGotoState_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[44]);
}

// ===================================================================

class PlayerController_ClientReceiveLocalizedMessage_Params::_Internal {
 public:
  static const ::unrealpb::UnrealObjectRef& relatedplayerstate_1(const PlayerController_ClientReceiveLocalizedMessage_Params* msg);
  static const ::unrealpb::UnrealObjectRef& relatedplayerstate_2(const PlayerController_ClientReceiveLocalizedMessage_Params* msg);
  static const ::unrealpb::UnrealObjectRef& optionalobject(const PlayerController_ClientReceiveLocalizedMessage_Params* msg);
};

const ::unrealpb::UnrealObjectRef&
PlayerController_ClientReceiveLocalizedMessage_Params::_Internal::relatedplayerstate_1(const PlayerController_ClientReceiveLocalizedMessage_Params* msg) {
  return *msg->_impl_.relatedplayerstate_1_;
}
const ::unrealpb::UnrealObjectRef&
PlayerController_ClientReceiveLocalizedMessage_Params::_Internal::relatedplayerstate_2(const PlayerController_ClientReceiveLocalizedMessage_Params* msg) {
  return *msg->_impl_.relatedplayerstate_2_;
}
const ::unrealpb::UnrealObjectRef&
PlayerController_ClientReceiveLocalizedMessage_Params::_Internal::optionalobject(const PlayerController_ClientReceiveLocalizedMessage_Params* msg) {
  return *msg->_impl_.optionalobject_;
}
PlayerController_ClientReceiveLocalizedMessage_Params::PlayerController_ClientReceiveLocalizedMessage_Params(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params)
}
PlayerController_ClientReceiveLocalizedMessage_Params::PlayerController_ClientReceiveLocalizedMessage_Params(const PlayerController_ClientReceiveLocalizedMessage_Params& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlayerController_ClientReceiveLocalizedMessage_Params* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.relatedplayerstate_1_){nullptr}
    , decltype(_impl_.relatedplayerstate_2_){nullptr}
    , decltype(_impl_.optionalobject_){nullptr}
    , decltype(_impl_.switch__){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_relatedplayerstate_1()) {
    _this->_impl_.relatedplayerstate_1_ = new ::unrealpb::UnrealObjectRef(*from._impl_.relatedplayerstate_1_);
  }
  if (from._internal_has_relatedplayerstate_2()) {
    _this->_impl_.relatedplayerstate_2_ = new ::unrealpb::UnrealObjectRef(*from._impl_.relatedplayerstate_2_);
  }
  if (from._internal_has_optionalobject()) {
    _this->_impl_.optionalobject_ = new ::unrealpb::UnrealObjectRef(*from._impl_.optionalobject_);
  }
  _this->_impl_.switch__ = from._impl_.switch__;
  // @@protoc_insertion_point(copy_constructor:unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params)
}

inline void PlayerController_ClientReceiveLocalizedMessage_Params::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.relatedplayerstate_1_){nullptr}
    , decltype(_impl_.relatedplayerstate_2_){nullptr}
    , decltype(_impl_.optionalobject_){nullptr}
    , decltype(_impl_.switch__){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlayerController_ClientReceiveLocalizedMessage_Params::~PlayerController_ClientReceiveLocalizedMessage_Params() {
  // @@protoc_insertion_point(destructor:unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlayerController_ClientReceiveLocalizedMessage_Params::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  if (this != internal_default_instance()) delete _impl_.relatedplayerstate_1_;
  if (this != internal_default_instance()) delete _impl_.relatedplayerstate_2_;
  if (this != internal_default_instance()) delete _impl_.optionalobject_;
}

void PlayerController_ClientReceiveLocalizedMessage_Params::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlayerController_ClientReceiveLocalizedMessage_Params::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.relatedplayerstate_1_ != nullptr) {
    delete _impl_.relatedplayerstate_1_;
  }
  _impl_.relatedplayerstate_1_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.relatedplayerstate_2_ != nullptr) {
    delete _impl_.relatedplayerstate_2_;
  }
  _impl_.relatedplayerstate_2_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.optionalobject_ != nullptr) {
    delete _impl_.optionalobject_;
  }
  _impl_.optionalobject_ = nullptr;
  _impl_.switch__ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlayerController_ClientReceiveLocalizedMessage_Params::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params.message"));
        } else
          goto handle_unusual;
        continue;
      // int32 switch = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.switch__ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.UnrealObjectRef relatedPlayerState_1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_relatedplayerstate_1(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.UnrealObjectRef relatedPlayerState_2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_relatedplayerstate_2(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.UnrealObjectRef optionalObject = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_optionalobject(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlayerController_ClientReceiveLocalizedMessage_Params::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params.message");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_message(), target);
  }

  // int32 switch = 2;
  if (this->_internal_switch_() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_switch_(), target);
  }

  // .unrealpb.UnrealObjectRef relatedPlayerState_1 = 3;
  if (this->_internal_has_relatedplayerstate_1()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::relatedplayerstate_1(this),
        _Internal::relatedplayerstate_1(this).GetCachedSize(), target, stream);
  }

  // .unrealpb.UnrealObjectRef relatedPlayerState_2 = 4;
  if (this->_internal_has_relatedplayerstate_2()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::relatedplayerstate_2(this),
        _Internal::relatedplayerstate_2(this).GetCachedSize(), target, stream);
  }

  // .unrealpb.UnrealObjectRef optionalObject = 5;
  if (this->_internal_has_optionalobject()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::optionalobject(this),
        _Internal::optionalobject(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params)
  return target;
}

size_t PlayerController_ClientReceiveLocalizedMessage_Params::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string message = 1;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_message());
  }

  // .unrealpb.UnrealObjectRef relatedPlayerState_1 = 3;
  if (this->_internal_has_relatedplayerstate_1()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.relatedplayerstate_1_);
  }

  // .unrealpb.UnrealObjectRef relatedPlayerState_2 = 4;
  if (this->_internal_has_relatedplayerstate_2()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.relatedplayerstate_2_);
  }

  // .unrealpb.UnrealObjectRef optionalObject = 5;
  if (this->_internal_has_optionalobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.optionalobject_);
  }

  // int32 switch = 2;
  if (this->_internal_switch_() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_switch_());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlayerController_ClientReceiveLocalizedMessage_Params::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlayerController_ClientReceiveLocalizedMessage_Params::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlayerController_ClientReceiveLocalizedMessage_Params::GetClassData() const { return &_class_data_; }


void PlayerController_ClientReceiveLocalizedMessage_Params::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlayerController_ClientReceiveLocalizedMessage_Params*>(&to_msg);
  auto& from = static_cast<const PlayerController_ClientReceiveLocalizedMessage_Params&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (from._internal_has_relatedplayerstate_1()) {
    _this->_internal_mutable_relatedplayerstate_1()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_relatedplayerstate_1());
  }
  if (from._internal_has_relatedplayerstate_2()) {
    _this->_internal_mutable_relatedplayerstate_2()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_relatedplayerstate_2());
  }
  if (from._internal_has_optionalobject()) {
    _this->_internal_mutable_optionalobject()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_optionalobject());
  }
  if (from._internal_switch_() != 0) {
    _this->_internal_set_switch_(from._internal_switch_());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlayerController_ClientReceiveLocalizedMessage_Params::CopyFrom(const PlayerController_ClientReceiveLocalizedMessage_Params& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PlayerController_ClientReceiveLocalizedMessage_Params)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerController_ClientReceiveLocalizedMessage_Params::IsInitialized() const {
  return true;
}

void PlayerController_ClientReceiveLocalizedMessage_Params::InternalSwap(PlayerController_ClientReceiveLocalizedMessage_Params* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlayerController_ClientReceiveLocalizedMessage_Params, _impl_.switch__)
      + sizeof(PlayerController_ClientReceiveLocalizedMessage_Params::_impl_.switch__)
      - PROTOBUF_FIELD_OFFSET(PlayerController_ClientReceiveLocalizedMessage_Params, _impl_.relatedplayerstate_1_)>(
          reinterpret_cast<char*>(&_impl_.relatedplayerstate_1_),
          reinterpret_cast<char*>(&other->_impl_.relatedplayerstate_1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlayerController_ClientReceiveLocalizedMessage_Params::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[45]);
}

// ===================================================================

class GameStateBase::_Internal {
 public:
  using HasBits = decltype(std::declval<GameStateBase>()._impl_._has_bits_);
  static void set_has_spectatorclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_gamemodeclassname(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_replicatedworldtimeseconds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_breplicatedhasbegunplay(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

GameStateBase::GameStateBase(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.GameStateBase)
}
GameStateBase::GameStateBase(const GameStateBase& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GameStateBase* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.spectatorclassname_){}
    , decltype(_impl_.gamemodeclassname_){}
    , decltype(_impl_.replicatedworldtimeseconds_){}
    , decltype(_impl_.breplicatedhasbegunplay_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.spectatorclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spectatorclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_spectatorclassname()) {
    _this->_impl_.spectatorclassname_.Set(from._internal_spectatorclassname(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gamemodeclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gamemodeclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gamemodeclassname()) {
    _this->_impl_.gamemodeclassname_.Set(from._internal_gamemodeclassname(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.replicatedworldtimeseconds_, &from._impl_.replicatedworldtimeseconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.breplicatedhasbegunplay_) -
    reinterpret_cast<char*>(&_impl_.replicatedworldtimeseconds_)) + sizeof(_impl_.breplicatedhasbegunplay_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.GameStateBase)
}

inline void GameStateBase::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.spectatorclassname_){}
    , decltype(_impl_.gamemodeclassname_){}
    , decltype(_impl_.replicatedworldtimeseconds_){0}
    , decltype(_impl_.breplicatedhasbegunplay_){false}
  };
  _impl_.spectatorclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.spectatorclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gamemodeclassname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gamemodeclassname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GameStateBase::~GameStateBase() {
  // @@protoc_insertion_point(destructor:unrealpb.GameStateBase)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GameStateBase::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.spectatorclassname_.Destroy();
  _impl_.gamemodeclassname_.Destroy();
}

void GameStateBase::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GameStateBase::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.GameStateBase)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.spectatorclassname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.gamemodeclassname_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.replicatedworldtimeseconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.breplicatedhasbegunplay_) -
        reinterpret_cast<char*>(&_impl_.replicatedworldtimeseconds_)) + sizeof(_impl_.breplicatedhasbegunplay_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameStateBase::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string spectatorClassName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_spectatorclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.GameStateBase.spectatorClassName"));
        } else
          goto handle_unusual;
        continue;
      // optional string gameModeClassName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_gamemodeclassname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.GameStateBase.gameModeClassName"));
        } else
          goto handle_unusual;
        continue;
      // optional float replicatedWorldTimeSeconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_replicatedworldtimeseconds(&has_bits);
          _impl_.replicatedworldtimeseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool bReplicatedHasBegunPlay = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_breplicatedhasbegunplay(&has_bits);
          _impl_.breplicatedhasbegunplay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameStateBase::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.GameStateBase)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string spectatorClassName = 2;
  if (_internal_has_spectatorclassname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_spectatorclassname().data(), static_cast<int>(this->_internal_spectatorclassname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.GameStateBase.spectatorClassName");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_spectatorclassname(), target);
  }

  // optional string gameModeClassName = 3;
  if (_internal_has_gamemodeclassname()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_gamemodeclassname().data(), static_cast<int>(this->_internal_gamemodeclassname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.GameStateBase.gameModeClassName");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_gamemodeclassname(), target);
  }

  // optional float replicatedWorldTimeSeconds = 4;
  if (_internal_has_replicatedworldtimeseconds()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_replicatedworldtimeseconds(), target);
  }

  // optional bool bReplicatedHasBegunPlay = 5;
  if (_internal_has_breplicatedhasbegunplay()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_breplicatedhasbegunplay(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.GameStateBase)
  return target;
}

size_t GameStateBase::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.GameStateBase)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string spectatorClassName = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_spectatorclassname());
    }

    // optional string gameModeClassName = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gamemodeclassname());
    }

    // optional float replicatedWorldTimeSeconds = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional bool bReplicatedHasBegunPlay = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameStateBase::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GameStateBase::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameStateBase::GetClassData() const { return &_class_data_; }


void GameStateBase::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GameStateBase*>(&to_msg);
  auto& from = static_cast<const GameStateBase&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.GameStateBase)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_spectatorclassname(from._internal_spectatorclassname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_gamemodeclassname(from._internal_gamemodeclassname());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.replicatedworldtimeseconds_ = from._impl_.replicatedworldtimeseconds_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.breplicatedhasbegunplay_ = from._impl_.breplicatedhasbegunplay_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameStateBase::CopyFrom(const GameStateBase& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.GameStateBase)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameStateBase::IsInitialized() const {
  return true;
}

void GameStateBase::InternalSwap(GameStateBase* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.spectatorclassname_, lhs_arena,
      &other->_impl_.spectatorclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gamemodeclassname_, lhs_arena,
      &other->_impl_.gamemodeclassname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameStateBase, _impl_.breplicatedhasbegunplay_)
      + sizeof(GameStateBase::_impl_.breplicatedhasbegunplay_)
      - PROTOBUF_FIELD_OFFSET(GameStateBase, _impl_.replicatedworldtimeseconds_)>(
          reinterpret_cast<char*>(&_impl_.replicatedworldtimeseconds_),
          reinterpret_cast<char*>(&other->_impl_.replicatedworldtimeseconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameStateBase::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[46]);
}

// ===================================================================

class PawnState::_Internal {
 public:
  using HasBits = decltype(std::declval<PawnState>()._impl_._has_bits_);
  static const ::unrealpb::UnrealObjectRef& playerstate(const PawnState* msg);
  static const ::unrealpb::UnrealObjectRef& controller(const PawnState* msg);
  static void set_has_remoteviewpitch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::unrealpb::UnrealObjectRef&
PawnState::_Internal::playerstate(const PawnState* msg) {
  return *msg->_impl_.playerstate_;
}
const ::unrealpb::UnrealObjectRef&
PawnState::_Internal::controller(const PawnState* msg) {
  return *msg->_impl_.controller_;
}
PawnState::PawnState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.PawnState)
}
PawnState::PawnState(const PawnState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PawnState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playerstate_){nullptr}
    , decltype(_impl_.controller_){nullptr}
    , decltype(_impl_.remoteviewpitch_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_playerstate()) {
    _this->_impl_.playerstate_ = new ::unrealpb::UnrealObjectRef(*from._impl_.playerstate_);
  }
  if (from._internal_has_controller()) {
    _this->_impl_.controller_ = new ::unrealpb::UnrealObjectRef(*from._impl_.controller_);
  }
  _this->_impl_.remoteviewpitch_ = from._impl_.remoteviewpitch_;
  // @@protoc_insertion_point(copy_constructor:unrealpb.PawnState)
}

inline void PawnState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playerstate_){nullptr}
    , decltype(_impl_.controller_){nullptr}
    , decltype(_impl_.remoteviewpitch_){0u}
  };
}

PawnState::~PawnState() {
  // @@protoc_insertion_point(destructor:unrealpb.PawnState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PawnState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.playerstate_;
  if (this != internal_default_instance()) delete _impl_.controller_;
}

void PawnState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PawnState::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.PawnState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.playerstate_ != nullptr) {
    delete _impl_.playerstate_;
  }
  _impl_.playerstate_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.controller_ != nullptr) {
    delete _impl_.controller_;
  }
  _impl_.controller_ = nullptr;
  _impl_.remoteviewpitch_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PawnState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .unrealpb.UnrealObjectRef playerState = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_playerstate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .unrealpb.UnrealObjectRef controller = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 remoteViewPitch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_remoteviewpitch(&has_bits);
          _impl_.remoteviewpitch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PawnState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.PawnState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef playerState = 1;
  if (this->_internal_has_playerstate()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::playerstate(this),
        _Internal::playerstate(this).GetCachedSize(), target, stream);
  }

  // .unrealpb.UnrealObjectRef controller = 2;
  if (this->_internal_has_controller()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::controller(this),
        _Internal::controller(this).GetCachedSize(), target, stream);
  }

  // optional uint32 remoteViewPitch = 3;
  if (_internal_has_remoteviewpitch()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_remoteviewpitch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.PawnState)
  return target;
}

size_t PawnState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.PawnState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .unrealpb.UnrealObjectRef playerState = 1;
  if (this->_internal_has_playerstate()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.playerstate_);
  }

  // .unrealpb.UnrealObjectRef controller = 2;
  if (this->_internal_has_controller()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.controller_);
  }

  // optional uint32 remoteViewPitch = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_remoteviewpitch());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PawnState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PawnState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PawnState::GetClassData() const { return &_class_data_; }


void PawnState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PawnState*>(&to_msg);
  auto& from = static_cast<const PawnState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.PawnState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_playerstate()) {
    _this->_internal_mutable_playerstate()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_playerstate());
  }
  if (from._internal_has_controller()) {
    _this->_internal_mutable_controller()->::unrealpb::UnrealObjectRef::MergeFrom(
        from._internal_controller());
  }
  if (from._internal_has_remoteviewpitch()) {
    _this->_internal_set_remoteviewpitch(from._internal_remoteviewpitch());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PawnState::CopyFrom(const PawnState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.PawnState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PawnState::IsInitialized() const {
  return true;
}

void PawnState::InternalSwap(PawnState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PawnState, _impl_.remoteviewpitch_)
      + sizeof(PawnState::_impl_.remoteviewpitch_)
      - PROTOBUF_FIELD_OFFSET(PawnState, _impl_.playerstate_)>(
          reinterpret_cast<char*>(&_impl_.playerstate_),
          reinterpret_cast<char*>(&other->_impl_.playerstate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PawnState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[47]);
}

// ===================================================================

class FClientAdjustment::_Internal {
 public:
  using HasBits = decltype(std::declval<FClientAdjustment>()._impl_._has_bits_);
  static void set_has_backgoodmove(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::unrealpb::FVector& newloc(const FClientAdjustment* msg);
  static void set_has_newloc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::unrealpb::FVector& newvel(const FClientAdjustment* msg);
  static void set_has_newvel(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::unrealpb::FVector& newrot(const FClientAdjustment* msg);
  static void set_has_newrot(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::unrealpb::UnrealObjectRef& newbase(const FClientAdjustment* msg);
  static void set_has_newbase(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_newbasebonename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bbaserelativeposition(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::unrealpb::FRootMotionSourceGroup& rootmotionsourcecorrection(const FClientAdjustment* msg);
  static void set_has_rootmotionsourcecorrection(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::unrealpb::FVector& rootmotionrotation(const FClientAdjustment* msg);
  static void set_has_rootmotionrotation(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_movementmode(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::unrealpb::FVector&
FClientAdjustment::_Internal::newloc(const FClientAdjustment* msg) {
  return *msg->_impl_.newloc_;
}
const ::unrealpb::FVector&
FClientAdjustment::_Internal::newvel(const FClientAdjustment* msg) {
  return *msg->_impl_.newvel_;
}
const ::unrealpb::FVector&
FClientAdjustment::_Internal::newrot(const FClientAdjustment* msg) {
  return *msg->_impl_.newrot_;
}
const ::unrealpb::UnrealObjectRef&
FClientAdjustment::_Internal::newbase(const FClientAdjustment* msg) {
  return *msg->_impl_.newbase_;
}
const ::unrealpb::FRootMotionSourceGroup&
FClientAdjustment::_Internal::rootmotionsourcecorrection(const FClientAdjustment* msg) {
  return *msg->_impl_.rootmotionsourcecorrection_;
}
const ::unrealpb::FVector&
FClientAdjustment::_Internal::rootmotionrotation(const FClientAdjustment* msg) {
  return *msg->_impl_.rootmotionrotation_;
}
FClientAdjustment::FClientAdjustment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:unrealpb.FClientAdjustment)
}
FClientAdjustment::FClientAdjustment(const FClientAdjustment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FClientAdjustment* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.newbasebonename_){}
    , decltype(_impl_.newloc_){nullptr}
    , decltype(_impl_.newvel_){nullptr}
    , decltype(_impl_.newrot_){nullptr}
    , decltype(_impl_.newbase_){nullptr}
    , decltype(_impl_.rootmotionsourcecorrection_){nullptr}
    , decltype(_impl_.rootmotionrotation_){nullptr}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.backgoodmove_){}
    , decltype(_impl_.bbaserelativeposition_){}
    , decltype(_impl_.movementmode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.newbasebonename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newbasebonename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_newbasebonename()) {
    _this->_impl_.newbasebonename_.Set(from._internal_newbasebonename(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_newloc()) {
    _this->_impl_.newloc_ = new ::unrealpb::FVector(*from._impl_.newloc_);
  }
  if (from._internal_has_newvel()) {
    _this->_impl_.newvel_ = new ::unrealpb::FVector(*from._impl_.newvel_);
  }
  if (from._internal_has_newrot()) {
    _this->_impl_.newrot_ = new ::unrealpb::FVector(*from._impl_.newrot_);
  }
  if (from._internal_has_newbase()) {
    _this->_impl_.newbase_ = new ::unrealpb::UnrealObjectRef(*from._impl_.newbase_);
  }
  if (from._internal_has_rootmotionsourcecorrection()) {
    _this->_impl_.rootmotionsourcecorrection_ = new ::unrealpb::FRootMotionSourceGroup(*from._impl_.rootmotionsourcecorrection_);
  }
  if (from._internal_has_rootmotionrotation()) {
    _this->_impl_.rootmotionrotation_ = new ::unrealpb::FVector(*from._impl_.rootmotionrotation_);
  }
  ::memcpy(&_impl_.timestamp_, &from._impl_.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.movementmode_) -
    reinterpret_cast<char*>(&_impl_.timestamp_)) + sizeof(_impl_.movementmode_));
  // @@protoc_insertion_point(copy_constructor:unrealpb.FClientAdjustment)
}

inline void FClientAdjustment::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.newbasebonename_){}
    , decltype(_impl_.newloc_){nullptr}
    , decltype(_impl_.newvel_){nullptr}
    , decltype(_impl_.newrot_){nullptr}
    , decltype(_impl_.newbase_){nullptr}
    , decltype(_impl_.rootmotionsourcecorrection_){nullptr}
    , decltype(_impl_.rootmotionrotation_){nullptr}
    , decltype(_impl_.timestamp_){0}
    , decltype(_impl_.backgoodmove_){false}
    , decltype(_impl_.bbaserelativeposition_){false}
    , decltype(_impl_.movementmode_){0u}
  };
  _impl_.newbasebonename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.newbasebonename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FClientAdjustment::~FClientAdjustment() {
  // @@protoc_insertion_point(destructor:unrealpb.FClientAdjustment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FClientAdjustment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.newbasebonename_.Destroy();
  if (this != internal_default_instance()) delete _impl_.newloc_;
  if (this != internal_default_instance()) delete _impl_.newvel_;
  if (this != internal_default_instance()) delete _impl_.newrot_;
  if (this != internal_default_instance()) delete _impl_.newbase_;
  if (this != internal_default_instance()) delete _impl_.rootmotionsourcecorrection_;
  if (this != internal_default_instance()) delete _impl_.rootmotionrotation_;
}

void FClientAdjustment::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FClientAdjustment::Clear() {
// @@protoc_insertion_point(message_clear_start:unrealpb.FClientAdjustment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.newbasebonename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.newloc_ != nullptr);
      _impl_.newloc_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.newvel_ != nullptr);
      _impl_.newvel_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.newrot_ != nullptr);
      _impl_.newrot_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.newbase_ != nullptr);
      _impl_.newbase_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.rootmotionsourcecorrection_ != nullptr);
      _impl_.rootmotionsourcecorrection_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.rootmotionrotation_ != nullptr);
      _impl_.rootmotionrotation_->Clear();
    }
  }
  _impl_.timestamp_ = 0;
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.backgoodmove_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.movementmode_) -
        reinterpret_cast<char*>(&_impl_.backgoodmove_)) + sizeof(_impl_.movementmode_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FClientAdjustment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool bAckGoodMove = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_backgoodmove(&has_bits);
          _impl_.backgoodmove_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float timeStamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_timestamp(&has_bits);
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector newLoc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_newloc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector newVel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_newvel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector newRot = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_newrot(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.UnrealObjectRef newBase = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_newbase(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string newBaseBoneName = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_newbasebonename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "unrealpb.FClientAdjustment.newBaseBoneName"));
        } else
          goto handle_unusual;
        continue;
      // optional bool bBaseRelativePosition = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_bbaserelativeposition(&has_bits);
          _impl_.bbaserelativeposition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FRootMotionSourceGroup rootMotionSourceCorrection = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_rootmotionsourcecorrection(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .unrealpb.FVector rootMotionRotation = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_rootmotionrotation(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 movementMode = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_movementmode(&has_bits);
          _impl_.movementmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FClientAdjustment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:unrealpb.FClientAdjustment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional bool bAckGoodMove = 1;
  if (_internal_has_backgoodmove()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_backgoodmove(), target);
  }

  // optional float timeStamp = 2;
  if (_internal_has_timestamp()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_timestamp(), target);
  }

  // optional .unrealpb.FVector newLoc = 3;
  if (_internal_has_newloc()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::newloc(this),
        _Internal::newloc(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector newVel = 4;
  if (_internal_has_newvel()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::newvel(this),
        _Internal::newvel(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector newRot = 5;
  if (_internal_has_newrot()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::newrot(this),
        _Internal::newrot(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.UnrealObjectRef newBase = 6;
  if (_internal_has_newbase()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::newbase(this),
        _Internal::newbase(this).GetCachedSize(), target, stream);
  }

  // optional string newBaseBoneName = 7;
  if (_internal_has_newbasebonename()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_newbasebonename().data(), static_cast<int>(this->_internal_newbasebonename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "unrealpb.FClientAdjustment.newBaseBoneName");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_newbasebonename(), target);
  }

  // optional bool bBaseRelativePosition = 8;
  if (_internal_has_bbaserelativeposition()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_bbaserelativeposition(), target);
  }

  // optional .unrealpb.FRootMotionSourceGroup rootMotionSourceCorrection = 9;
  if (_internal_has_rootmotionsourcecorrection()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::rootmotionsourcecorrection(this),
        _Internal::rootmotionsourcecorrection(this).GetCachedSize(), target, stream);
  }

  // optional .unrealpb.FVector rootMotionRotation = 10;
  if (_internal_has_rootmotionrotation()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::rootmotionrotation(this),
        _Internal::rootmotionrotation(this).GetCachedSize(), target, stream);
  }

  // optional uint32 movementMode = 11;
  if (_internal_has_movementmode()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_movementmode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:unrealpb.FClientAdjustment)
  return target;
}

size_t FClientAdjustment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:unrealpb.FClientAdjustment)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string newBaseBoneName = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_newbasebonename());
    }

    // optional .unrealpb.FVector newLoc = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newloc_);
    }

    // optional .unrealpb.FVector newVel = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newvel_);
    }

    // optional .unrealpb.FVector newRot = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newrot_);
    }

    // optional .unrealpb.UnrealObjectRef newBase = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.newbase_);
    }

    // optional .unrealpb.FRootMotionSourceGroup rootMotionSourceCorrection = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rootmotionsourcecorrection_);
    }

    // optional .unrealpb.FVector rootMotionRotation = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rootmotionrotation_);
    }

    // optional float timeStamp = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional bool bAckGoodMove = 1;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool bBaseRelativePosition = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional uint32 movementMode = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_movementmode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FClientAdjustment::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FClientAdjustment::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FClientAdjustment::GetClassData() const { return &_class_data_; }


void FClientAdjustment::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FClientAdjustment*>(&to_msg);
  auto& from = static_cast<const FClientAdjustment&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:unrealpb.FClientAdjustment)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_newbasebonename(from._internal_newbasebonename());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_newloc()->::unrealpb::FVector::MergeFrom(
          from._internal_newloc());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_newvel()->::unrealpb::FVector::MergeFrom(
          from._internal_newvel());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_newrot()->::unrealpb::FVector::MergeFrom(
          from._internal_newrot());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_newbase()->::unrealpb::UnrealObjectRef::MergeFrom(
          from._internal_newbase());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_rootmotionsourcecorrection()->::unrealpb::FRootMotionSourceGroup::MergeFrom(
          from._internal_rootmotionsourcecorrection());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_rootmotionrotation()->::unrealpb::FVector::MergeFrom(
          from._internal_rootmotionrotation());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.timestamp_ = from._impl_.timestamp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.backgoodmove_ = from._impl_.backgoodmove_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.bbaserelativeposition_ = from._impl_.bbaserelativeposition_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.movementmode_ = from._impl_.movementmode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FClientAdjustment::CopyFrom(const FClientAdjustment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:unrealpb.FClientAdjustment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FClientAdjustment::IsInitialized() const {
  return true;
}

void FClientAdjustment::InternalSwap(FClientAdjustment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.newbasebonename_, lhs_arena,
      &other->_impl_.newbasebonename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FClientAdjustment, _impl_.movementmode_)
      + sizeof(FClientAdjustment::_impl_.movementmode_)
      - PROTOBUF_FIELD_OFFSET(FClientAdjustment, _impl_.newloc_)>(
          reinterpret_cast<char*>(&_impl_.newloc_),
          reinterpret_cast<char*>(&other->_impl_.newloc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FClientAdjustment::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_unreal_5fcommon_2eproto_getter, &descriptor_table_unreal_5fcommon_2eproto_once,
      file_level_metadata_unreal_5fcommon_2eproto[48]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace unrealpb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::unrealpb::FVector*
Arena::CreateMaybeMessage< ::unrealpb::FVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::FVector >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::UnrealObjectRef_GuidCachedObject*
Arena::CreateMaybeMessage< ::unrealpb::UnrealObjectRef_GuidCachedObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::UnrealObjectRef_GuidCachedObject >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::UnrealObjectRef*
Arena::CreateMaybeMessage< ::unrealpb::UnrealObjectRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::UnrealObjectRef >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::ActorComponentRef*
Arena::CreateMaybeMessage< ::unrealpb::ActorComponentRef >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::ActorComponentRef >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::RemoteFunctionMessage*
Arena::CreateMaybeMessage< ::unrealpb::RemoteFunctionMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::RemoteFunctionMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::SpawnObjectMessage*
Arena::CreateMaybeMessage< ::unrealpb::SpawnObjectMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::SpawnObjectMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::DestroyObjectMessage*
Arena::CreateMaybeMessage< ::unrealpb::DestroyObjectMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::DestroyObjectMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::HandoverContext*
Arena::CreateMaybeMessage< ::unrealpb::HandoverContext >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::HandoverContext >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::GetHandoverContextMessage*
Arena::CreateMaybeMessage< ::unrealpb::GetHandoverContextMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::GetHandoverContextMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::GetHandoverContextResultMessage*
Arena::CreateMaybeMessage< ::unrealpb::GetHandoverContextResultMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::GetHandoverContextResultMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::HandoverData*
Arena::CreateMaybeMessage< ::unrealpb::HandoverData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::HandoverData >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::GetUnrealObjectRefMessage*
Arena::CreateMaybeMessage< ::unrealpb::GetUnrealObjectRefMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::GetUnrealObjectRefMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::GetUnrealObjectRefResultMessage*
Arena::CreateMaybeMessage< ::unrealpb::GetUnrealObjectRefResultMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::GetUnrealObjectRefResultMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::SpatialEntityState*
Arena::CreateMaybeMessage< ::unrealpb::SpatialEntityState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::SpatialEntityState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::SpatialChannelData_EntitiesEntry_DoNotUse*
Arena::CreateMaybeMessage< ::unrealpb::SpatialChannelData_EntitiesEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::SpatialChannelData_EntitiesEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::SpatialChannelData*
Arena::CreateMaybeMessage< ::unrealpb::SpatialChannelData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::SpatialChannelData >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::FRepMovement*
Arena::CreateMaybeMessage< ::unrealpb::FRepMovement >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::FRepMovement >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::FRepAttachment*
Arena::CreateMaybeMessage< ::unrealpb::FRepAttachment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::FRepAttachment >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::ActorState*
Arena::CreateMaybeMessage< ::unrealpb::ActorState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::ActorState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::ActorComponentState*
Arena::CreateMaybeMessage< ::unrealpb::ActorComponentState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::ActorComponentState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::SceneComponentState*
Arena::CreateMaybeMessage< ::unrealpb::SceneComponentState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::SceneComponentState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::FBasedMovementInfo*
Arena::CreateMaybeMessage< ::unrealpb::FBasedMovementInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::FBasedMovementInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings*
Arena::CreateMaybeMessage< ::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::FRootMotionSource_FRootMotionFinishVelocitySettings >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::FRootMotionSource*
Arena::CreateMaybeMessage< ::unrealpb::FRootMotionSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::FRootMotionSource >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::FRootMotionSourceGroup*
Arena::CreateMaybeMessage< ::unrealpb::FRootMotionSourceGroup >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::FRootMotionSourceGroup >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::FRepRootMotionMontage*
Arena::CreateMaybeMessage< ::unrealpb::FRepRootMotionMontage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::FRepRootMotionMontage >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::CharacterState*
Arena::CreateMaybeMessage< ::unrealpb::CharacterState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::CharacterState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::Character_ServerMovePacked_Params*
Arena::CreateMaybeMessage< ::unrealpb::Character_ServerMovePacked_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::Character_ServerMovePacked_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::Character_ClientMoveResponsePacked_Params*
Arena::CreateMaybeMessage< ::unrealpb::Character_ClientMoveResponsePacked_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::Character_ClientMoveResponsePacked_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerState*
Arena::CreateMaybeMessage< ::unrealpb::PlayerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::ControllerState*
Arena::CreateMaybeMessage< ::unrealpb::ControllerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::ControllerState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::Controller_ClientSetLocation_Params*
Arena::CreateMaybeMessage< ::unrealpb::Controller_ClientSetLocation_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::Controller_ClientSetLocation_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::Controller_ClientSetRotation_Params*
Arena::CreateMaybeMessage< ::unrealpb::Controller_ClientSetRotation_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::Controller_ClientSetRotation_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerControllerState*
Arena::CreateMaybeMessage< ::unrealpb::PlayerControllerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerControllerState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ServerUpdateCamera_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ServerUpdateCamera_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ServerUpdateCamera_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientSetHUD_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientSetHUD_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientSetHUD_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientSetViewTarget_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientSetViewTarget_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientSetViewTarget_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientEnableNetworkVoice_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientEnableNetworkVoice_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientEnableNetworkVoice_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientCapBandwidth_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientCapBandwidth_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientCapBandwidth_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientRestart_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientRestart_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientRestart_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientSetCameraMode_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientSetCameraMode_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientSetCameraMode_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientRetryClientRestart_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientRetryClientRestart_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientRetryClientRestart_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ServerSetSpectatorLocation_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ServerSetSpectatorLocation_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ServerSetSpectatorLocation_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ServerAcknowledgePossession_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ServerAcknowledgePossession_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ServerAcknowledgePossession_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientGotoState_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientGotoState_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientGotoState_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PlayerController_ClientReceiveLocalizedMessage_Params*
Arena::CreateMaybeMessage< ::unrealpb::PlayerController_ClientReceiveLocalizedMessage_Params >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PlayerController_ClientReceiveLocalizedMessage_Params >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::GameStateBase*
Arena::CreateMaybeMessage< ::unrealpb::GameStateBase >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::GameStateBase >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::PawnState*
Arena::CreateMaybeMessage< ::unrealpb::PawnState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::PawnState >(arena);
}
template<> PROTOBUF_NOINLINE ::unrealpb::FClientAdjustment*
Arena::CreateMaybeMessage< ::unrealpb::FClientAdjustment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::unrealpb::FClientAdjustment >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
